Do you find your functional, integration and other web UI tests less robust than the other ?

Do you find yourselves fixing plenty of tests after just changing class attribute of some divs ?

Have you noticed the same code repeated on many places in your tests ?

*Arquillian Graphene Component Objects are here to help you!*

h3 What is it ?

* Set of APIs for well known web UI widgets like Calendar, Table or Autocomplete.
* Powerful mechanism for creating own components.
* A concept which differientate each component by its root element and make other parts referenced from this root element.
* A concept which leverages Selenium Webdriver under the hood together with all Graphene killer features.
* Set of utilities which make using this feature very easy in tests.

h3 Let's look how such component can be defined.

bc(prettify).. public class Calendar {

	@Root
	private WebElement root;

	@FindBy(css = "img:nth-of-type(1)")
	private WebElement showCalendarButton;

	@FindBy(className = "rf-cal-day-lbl")
	private WebElement popupWithCalendar;

	//other calendar specific parts to interact with

	@Override
	public void showCalendar() {

		if (!popupWithCalendar.isDisplayed()) {
			showCalendarButton.click();

			(new WebDriverWait(GrapheneContext.get(), 2)).until(new ExpectedCondition<Boolean>() {

            	public Boolean apply(WebDriver d) {

                	return popupWithCalendar.isDisplayed();
            	}
        	});			
		}
	}

	public void hideCalendar() {

		showCalendar();
	}

	private void gotoDate(Date date) {}

	//other calendar methods
}

Notice the @@Root@ annotation. The value for that field is automatically injected by Graphene to reference all defined @@FindBy@ elements from it. Such implementation is pretty generic and therefore reusable in all tests for different applications.

h3 Tests with using of such Component Objects is showcased in the following example.

bc(prettify).. @RunWith(Arquillian.class)
public class TestWhichUsesComponentObjects extend AbstractTest {

    @FindBy(xpath = "//div[@id='rootElement']")
    private CalendarImpl calendar;

    @FindBy(xpath = "//input")
    private WebElement input;

    @Page
    private TestPage testPage;

    @Test
    public void testCalendar {
        calendar.showCalendar();
        //other calendar API calls, asserts, etc.
    }
}

See how easily is Component Object defined in tests. Just by using WebDriver @@FindBy@@ annotation with reference to the root of the component, Other @WebElement@ objects are initialised as usually. A integration with Page Object pattern is achieved with @@Page@@ annotation. Such a page can contain other Component objects. Notice that all this initialisation is done automatically, so no need to initialise these elements in Before methods.

Future releases will be about completing the API of components and supporting more front end frameworks. Feel free to give a hand and to commit some of your ideas.

To try Component objects by ourselves, just check it out the Graphene 2.0.0.Alpha2 release. There you can find API for well known web UI widgets. The example implementation for RichFaces framework is temporarily hosted "here":https://github.com/jhuska/component-objects. Please be awere that these are Alpha releases and that it will be rapidly developed in the next weeks, so stay tuned for news.