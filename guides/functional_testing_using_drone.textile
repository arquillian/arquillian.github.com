---
layout: guide
title: Functional Testing using Graphene
authors: [mojavelinux, kpiwko, jhuska, lfryc, bleathem]
tags: [graphene, drone, selenium, as7]
description: Discover how Arquillian Graphene simplifies testing the web UI of your application.
guide_group: 2
guide_order: 3
---
This guide introduces you to the functional testing using Arquillian Graphene extension. After reading this guide, you'll be able to:

* Add required Arquillian extensions to your Arquillian-based test suite
* Package portions of your web application to test the web user interface (UI)
* Inject WebDriver API to your test case
* Control the browser using Graphene to validate the behavior of your web application

You'll appreciate how much heavy lifting Graphene is doing to perform automated functional testing!

h3. Assumptions

We'll assume that you've read the "Getting Started":/guides/getting_started guide and have an Arquillian test suite setup in your project. We'll be adding a simple JSF(JavaServer Faces) login form to the project as an example of a web UI to test. From there, you can apply these instructions to web pages written in any web framework you may need to test.

The instructions in this guide are specific to a Maven project, though remember that Arquillian is not tied to Maven in any way. We'll be running the tests on a JBoss AS 7 instance, though you can use any container supported by Arquillian that has a web container.

In this guide, we'll be using the following technologies:

* Arquillian
* Arquillian Drone
* Arquillian Graphene
* Selenium WebDriver
 
All listed technologies are a part of Arquillian test platform. Both Arquillian Drone and Graphene are working with "Selenium WebDriver":http://seleniumhq.org, which is in short "standard technology":https://dvcs.w3.org/hg/webdriver/raw-file/default/webdriver-spec.html for browsers automation. Arquillian Drone integrates Selenium framework with Arquillian and facilitates some of the tedious processes needed to test frontend of any web application. The Arquillian Graphene is built on top of "Selenium WebDriver API":http://selenium.googlecode.com/git/docs/api/java/org/openqa/selenium/WebDriver.html and adds lot of features for writing reusable and maintainable functional tests. You will see them in a minute!

If you are already familiar with Selenium, you'll discover that Arquillian manages the Selenium life cycle in much the same way it manages the container life cycle. If Selenium is new to you, this is a great opportunity to begin using its enhanced version Graphene to test the web UI of your application.

h3. Introducing Client Mode

If you'd ever written an Arquillian based test, you know that it looks almost the same as a unit test for the unit testing framework you are using. Let's look at an example of an Arquillian test that uses JUnit:

bc(prettify).. @RunWith(Arquillian.class)
public class BasicInContainerTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(MyBean.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }
    
    @Inject
    MyBean bean;
 
    @Test
    public void should_inject_bean_instance() {
        Assert.assertNotNull(bean);
    }
}

p. Here we've deployed a CDI bean to the server inside a bean archive. In the test, we've injected the instance of the bean, then asserted that the injection has occurred. Arquillian first enriches the archive with the test infrastructure. It then connects to the server to deploy the archive and execute the test method inside of the container by launching the JUnit test runner a second time inside that environment. Finally, Arquillian retrieves the results from that remote execution. This example demonstrates the default run mode of Arquillian: in-container. In a sense, the local JUnit runner is a client of the container, being driven by Arquillian.

The other run mode in Arquillian is the client run mode. In this mode, Arquillian deploys the test archive as is to the server. It then allows the tests to run in the same JVM as the test runner. Now your test case is a client of the container. The test no longer runs inside the container, yet Arquillian still handles the life cycle of the container as well as deployment of the test archive. It's the ideal mode for web UI testing.

h3. Enabling Client Mode

How do you activate client mode? Quite simply. You either mark a deployment as non-testable, meaning Arquillian will not enrich the archive, or you can mark a specified method with the annotation @@RunAsClient@. Here's an example:

bc(prettify).. @RunWith(Arquillian.class)
public class BasicClientTest {
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return ShrinkWrap.create(WebArchive.class)
            .addClasses(MyBean.class)
            .setWebXML("WEB-INF/web.xml");
    }
    
    @Test
    public void should_login_successfully() {
    }
}

p. It's also possible to mix in-container and client modes in the same test! Just leave off the @testable@ attribute. Any method annotated with @@RunAsClient@ will execute from the client, the remainder will execute inside the container, giving you the best of both worlds!

bc(prettify).. @RunWith(Arquillian.class)
public class MixedRunModeTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(MyBean.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }
    
    @Inject
    MyBean bean;
 
    @Test
    public void should_run_in_container() {
        // executed from the server JVM
        Assert.assertNotNull(bean);
    }

    @Test
    @RunAsClient
    public void should_run_as_client() {
        // executed from the client JVM
    }
}

p. Now that you understand how to run a test in client mode, let's check out how to test a web UI by using Arquillian Graphene to drive your browser.

h3. Graphene Overview

Arquillian Graphene is a set of extensions for "WebDriver API":http://docs.seleniumhq.org, focused on rapid development and usability in Java environment. Its API encourages people to write tests for AJAX-based web applications in concise and maintainable way. Graphene strives for reusable tests by simplifying the use of web page abstractions ("Page Objects":https://docs.jboss.org/author/display/ARQGRA2/Page+Objects and "Page Fragments":https://docs.jboss.org/author/display/ARQGRA2/Page+Fragments). You will get taste of Graphene API just in a minute!

Arquillian Graphene depends on Arquillian Drone, which is an extension that manages the life cycle of tested browsers. Drone simplifies the initial test setup and prepares tests for continuous integration in variety of web browsers.
 
Currently, the list of supported browsers is pretty large, a bounded set of those covered by Selenium project, e.g. Chrome, Firefox, Internet Explorer, Safari, Opera. It also supports "headless browsers":http://blog.arhg.net/2009/10/what-is-headless-browser.html PhantomJS and HTMLUnit. Like Arquillian Core, the Arquillian Graphene and  Arquillian Drone extensions are, well, pretty extensible.
  
Let's get Arquillian Graphene configured so that we can start writing some tests.

p(info). %Even though you don't have to learn Graphene in order to use WebDriver in Arquillian tests, it is highly recommended. When using Graphene, you will get most tedious processes connected to WebDriver usage under control and leverage best practices seamlessly.%

p(info). %For more information about how Drone can enable you Selenium 1 testing, or testing in the mobile environment, check out its "reference documentation":https://docs.jboss.org/author/display/ARQ/Drone.%

h3. Set Up Graphene

Let's start by setting up the libraries in the Maven pom.xml file that we need to use the Graphene extension. As with the previous tutorials, we need to instruct Maven which versions of the artifacts to use by importing a BOM(Bill of Materials), or version matrix. If you followed the getting started guide, you should already have a BOM defined for Arquillian in the @<dependencyManagement>@ section.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian</groupId>
            <artifactId>arquillian-bom</artifactId>
            <version>1.1.1.Final</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
<!-- clip -->

p. Below that @<dependency>@, add another entry for defining the version matrix for Drone and Selenium transitive dependencies, leaving you with the following result:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian</groupId>
            <artifactId>arquillian-bom</artifactId>
            <version>1.1.1.Final</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.arquillian.extension</groupId>
            <artifactId>arquillian-drone-bom</artifactId>
            <version>1.2.0.Beta1</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.arquillian.selenium</groupId>
            <artifactId>selenium-bom</artifactId>
            <version>2.35.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
<!-- clip -->

p. If you've set up Arquillian previously, you should already have the JUnit and Arquillian JUnit integration dependencies under @dependencies@ element.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>org.jboss.arquillian.junit</groupId>
        <artifactId>arquillian-junit-container</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <scope>test</scope>
        <version>4.8.1</version>
    </dependency>
</dependencies>
<!-- clip -->

p. Next, add the Graphene dependency, which brings you all the other required dependencies:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.graphene</groupId>
    <artifactId>graphene-webdriver</artifactId>
    <version>2.0.0.Beta1</version>
    <type>pom</type>
    <scope>test</scope>
</dependency>
<!-- clip -->


p. You have to specify the dependency on a container adapter. We will use JBoss AS 7 remote container, because it is an effective way of tests development. You can read more about "rapid test development turnaround":http://lukas.fryc.eu/blog/2013/06/testing-jsf-richfaces-arquillian-2-rapid-test-development.html.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.as</groupId>
    <artifactId>jboss-as-arquillian-container-remote</artifactId>
    <version>7.1.1.Final</version>
    <scope>test</scope>
</dependency>
<!-- clip -->

p(important). %If you are testing against multiple containers, then the container adapter should be included in a dedicated profile, as described in the "Getting Started":/guides/getting_started guide.%

p. You typically need to test your web application across different browsers. Let's add a uniform way of choosing which browser you are testing on to the @pom.xml@. Firstly, create profile for each desired browser.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<properties>
    <browser>phantomjs</browser> <!-- PhantomJS will be our default browser if no profile specified-->
</properties>
<!-- clip -->

<!-- clip -->
<profiles>
    <profile>
       <id>firefox</id>
       <properties>
          <browser>firefox</browser>
       </properties>
    </profile>
    <profile>
       <id>chrome</id>
       <properties>
           <browser>chrome</browser>
       </properties>
    </profile>

    <!-- feel free to add any other browser you like -->
</profiles>
<!-- clip -->

p. Secondly, you need to set the right system property in order to effectively change the Arquillian settings for browser selection. Add following to the @pom.xml@:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<build>
  <plugins>
    <plugin>
      <artifactId>maven-surefire-plugin</artifactId>
      <configuration>
        <systemProperties>
          <arq.extension.webdriver.browser>${browser}</arq.extension.webdriver.browser>
        </systemProperties>
      </configuration>
    </plugin>
  </plugins>
</build>
<!-- clip -->

p(info). %"PhantomJS":http://phantomjs.org/ can be used as default browser. Thanks to its ability to operate in resource-limited environments such as continuous integration servers, while closely simulating behavior of Chrome browser.%

h3. Create a Login Screen

When writing a web UI test, you have to make sure you deploy a complete web application, even if it's only a fraction of your full application (e.g., a micro application). Therefore, the @@Deployment@ method for these types of tests is going to be a bit more complex, but don't let it turn you off. Over time, you'll divide up the deployment into reusable parts to trim down the configuration on a per-test basis.

To create the login screen of the application, we need the following files and resources:

# Credentials bean to capture the username and password
# User bean to represent the current user
# Login controller to authenticate the user and produce the current user
# Login page
# Home page (landing page after successful login)

If you haven't done so already, open the project in your IDE. Next, create a @Credentials@ class in the @org.arquillian.example@ package.

div(filename). src/main/java/org/arquillian/example/Credentials.java

bc(prettify).. package org.arquillian.example;

import javax.enterprise.inject.Model;

@Model
public class Credentials {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

p. @Credentials@ is a request-scoped, named bean (as indicated by the @@Model@ stereotype annotation) to make it capable of capturing data from the JSF login form we are going to create.

Next, create the @User@ class in the same package. In a more advanced example, this class would likely serve as a JPA entity, able to retrieve the user's information from a database. For now, we'll stick with a more basic use case.

div(filename). src/main/java/org/arquillian/example/User.java

bc(prettify).. package org.arquillian.example;

public class User {
    private String username;

    public User() {}
    
    public User(String username) {
        this.username = username;
    }
    
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }
}

p. Next up, create the @LoginController@ class, again in the same package. For the purpose of this example, this implementation only accepts a user name and password of "demo" and issues a welcome message when the login is successful.

div(filename). src/main/java/org/arquillian/example/LoginController.java

bc(prettify).. //clip
package org.arquillian.example;

import java.io.Serializable;

import javax.enterprise.context.SessionScoped;
import javax.enterprise.inject.Produces;
import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;
import javax.inject.Inject;
import javax.inject.Named;

@Named
@SessionScoped
public class LoginController implements Serializable {
    private static final long serialVersionUID = 1L;

    private static final String SUCCESS_MESSAGE = "Welcome";
    private static final String FAILURE_MESSAGE =
        "Incorrect username and password combination";

    private User currentUser;
    private boolean renderedLoggedIn = false;
    
    @Inject
    private Credentials credentials;
    
    public String login() {
        if ("demo".equals(credentials.getUsername()) &&
            "demo".equals(credentials.getPassword())) {
            currentUser = new User("demo");
            FacesContext.getCurrentInstance().addMessage(null,
                new FacesMessage(SUCCESS_MESSAGE));
            return "home.xhtml";
        }

        FacesContext.getCurrentInstance().addMessage(null,
            new FacesMessage(FacesMessage.SEVERITY_WARN,
                FAILURE_MESSAGE, FAILURE_MESSAGE));
        return null;
    }
    
    public boolean isRenderedLoggedIn() {
        if(currentUser != null) {
            return renderedLoggedIn;
        } else {
            return false;
        }
    }
    
    public void renderLoggedIn() {
        this.renderedLoggedIn = true;
    }
    
    @Produces
    @Named
    public User getCurrentUser() {
        return currentUser;
    }
}
//clip

p. The @LoginController@ is session-scoped so that it can store the current user for the duration of the user's session and named so that it can be accessed by the action button on the login form.

Finally, we need to create the UI screens. In the @src/main/webapp@ directory, create a login page:

div(filename). src/main/webapp/login.xhtml

bc(prettify).. <!-- clip -->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ui="http://java.sun.com/jsf/facelets"
    xmlns:h="http://java.sun.com/jsf/html"
    xmlns:f="http://java.sun.com/jsf/core">
    <head>
        <title>Log in</title>
    </head>
    <body>
        <h:messages/>
        <h:form id="loginForm" prependIds="false">
            <h:panelGrid columns="2">
                <h:outputLabel for="userName">Username:</h:outputLabel>
                <h:inputText id="userName" value="#{credentials.username}"/>
                <h:outputLabel for="password">Password:</h:outputLabel>
                <h:inputSecret id="password" value="#{credentials.password}"/>
                <h:commandButton id="login" value="Log in"
                    action="#{loginController.login}"/>
            </h:panelGrid>
        </h:form>
    </body>
</html>
<!-- clip -->

p. and a home page:

div(filename). src/main/webapp/home.xhtml

bc(prettify).. <!-- clip -->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
 xmlns:ui="http://java.sun.com/jsf/facelets"
	xmlns:h="http://java.sun.com/jsf/html"
	xmlns:f="http://java.sun.com/jsf/core">
<h:head>
	<title>Home</title>
</h:head>
<h:body>
	<h:messages />
	<h:form prependIds="false">
		<h:commandButton value="Who Am I ?" action="#{loginController.renderLoggedIn}">
			<f:ajax render="whoami" />
		</h:commandButton>
		<h:panelGroup id="whoami">
			<h:panelGroup rendered="#{loginController.renderedLoggedIn}">
				<p>You are signed in as #{currentUser.username}.</p>
			</h:panelGroup>
		</h:panelGroup>
	</h:form>
</h:body>
</html>
<!-- clip -->

p. Now we need to write a test to see if these components come together to produce a functioning login screen.

h3. Create a Test Archive

Here's the shell of a test case for testing the logic screen with just the @@Deployment@ method in place. All the files all listed explicitly to illustrate what's being included.

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. package org.arquillian.example;

import java.io.File;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.asset.StringAsset;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class LoginScreenGrapheneTest {
    private static final String WEBAPP_SRC = "src/main/webapp";
    
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return ShrinkWrap.create(WebArchive.class, "login.war")
            .addClasses(Credentials.class, User.class, LoginController.class)
            .addAsWebResource(new File(WEBAPP_SRC, "login.xhtml"))
            .addAsWebResource(new File(WEBAPP_SRC, "home.xhtml"))
            .addAsWebInfResource(EmptyAsset.INSTANCE, "beans.xml")
            .addAsWebInfResource(
                new StringAsset("<faces-config version=\"2.0\"/>"),
                "faces-config.xml");
    }
}

p(important). %Don't forget to set @testable = false@ attribute on the @@Deployment@ annotation to enable client mode.%

p(warning). %The Java EE 6 specification requires a @faces-config.xml@ descriptor to be present in WEB-INF to activate JSF. Unlike @beans.xml@, however, the @faces-config.xml@ descriptor cannot be an empty file. It must contain at least the root node and the version attribute to specify the JSF version in use.%

p. If you have a lot of web pages that are part of the test, having to add them to the archive individually is tedious. Instead, you can import them in bulk using the @ExplodedImporter@ from ShrinkWrap. Here's an example of how to add all the web sources that end in .xhtml to the archive:

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
import org.jboss.shrinkwrap.api.Filters;
import org.jboss.shrinkwrap.api.GenericArchive;
import org.jboss.shrinkwrap.api.importer.ExplodedImporter;
// clip

return ShrinkWrap.create(WebArchive.class, "login.war")
    .addClasses(Credentials.class, User.class, LoginController.class)
    .merge(ShrinkWrap.create(GenericArchive.class).as(ExplodedImporter.class)
        .importDirectory(WEBAPP_SRC).as(GenericArchive.class),
        "/", Filters.include(".*\\.xhtml$"))
    .addAsWebInfResource(EmptyAsset.INSTANCE, "beans.xml")
    .addAsWebInfResource(
        new StringAsset("<faces-config version=\"2.0\"/>"),
        "faces-config.xml");

// clip

p. For more information about how to use @ExplodedImporter@ for this task, and alternative strategies, see "this FAQ":https://community.jboss.org/wiki/HowDoIAddAllWebResourcesToTheShrinkWrapArchive.

p. One way to trim this down is to move the creation of the archive to a utility class and refer to it whenever you need this particular micro application. That leaves you with a much simpler @@Deployment@ method:

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
@RunWith(Arquillian.class)
public class LoginScreenGrapheneTest {
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return Deployments.createLoginScreenDeployment();
    }
}

p. Now let's get a handle on Drone and Graphene.

h3. Inject the WebDriver API

Let's start with injecting well know @WebDriver@ object, which represents a handle to a browser:

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
import org.jboss.arquillian.drone.api.annotation.Drone;
import org.openqa.selenium.WebDriver;
// clip

@RunWith(Arquillian.class)
public class LoginScreenGrapheneTest {
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return Deployments.createLoginScreenDeployment();
    }

    @Drone
    private WebDriver browser;
}

p. *That's it!* The @@Drone@ injection point tells Drone to create an instance of the browser controller, "WebDriver":http://selenium.googlecode.com/git/docs/api/java/index.html, before the first client test is run, then inject that object into the test case.

*Oh wait!* Where is the Graphene? In fact, Graphene wraps the instance of a browser you have just injected. It instruments the WebDriver API in order to enable more advanced features. Where possible, it doesn't persuade any own syntax.

There's one more thing. We're testing web UI, but how do we know the URL of deployed application? Well, Arquillian already has a solution. Just use @@ArquillianResource@ to inject the URL of the deployed application.

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
import java.net.URL;
import org.jboss.arquillian.test.api.ArquillianResource;
// clip

@RunWith(Arquillian.class)
public class LoginScreenGrapheneTest {
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return Deployments.createLoginScreenDeployment();
    }

    @Drone
    private WebDriver browser;

    @ArquillianResource
    private URL deploymentUrl;
}

p. Now even the URL of your deployed archive is injected in the test. It's now time to drive the browser to verify the functionality of the web application.

h3. Drive the Browser

Here's the test method that pokes at the login screen to make sure it works. We use Graphene to verify that the welcome message appears after a successful login.

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
import static org.jboss.arquillian.graphene.Graphene.guardHttp;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;


@FindBy                                     // 2. injects an element
private WebElement userName;

@FindBy
private WebElement password;

@Test
public void should_login_successfully() {
    browser.get(deploymentUrl.toExternalForm() + "login.jsf");      // 1. open the tested page

    userName.sendKeys("demo");                                      // 3. control the page
    password.sendKeys("demo");

    guardHttp(loginButton).click();

    assertEquals("Welcome", facesMessage.getText().trim());
    whoAmI.click();
    waitAjax().until().element(signedAs).is().present();
    assertTrue(signedAs.getText().contains("demo"));
}
// clip

p. Once the browser is started and Drone injects @WebDriver@ handle to the test instance, we need to open a tested page (*step 1*). Notice how we are leveraging URL of an application deployed into a container.

p. We can finally start to control the page to test its behavior.

p. But before you can dive into controlling the page, you need to describe the page you are going to test - you need to locate elements on the page.

p. In *step 2*, we have injected a handle for element using @FindBy@ annotation. This annotation is known from being a base for a page logic encapsulation.

p. In *step 3*, we are just controlling the page using @WebElement@ API - the entry point for operations with DOM elements.

p(info). %Do you like how HTML and CSS helps you to split page logic and its presentation? In the same sense, @FindBy@ annotation splits page structure and test logic. You will get to know more advanced usage of page abstraction later in this guide.%

p. Finally you are able to run the test! Choose the @firefox@ profile in you project in your IDE (CTRL + P hotkey in Eclipse).
Right click on the test in your IDE and select Run As > JUnit test. Do not forget to have JBoss AS 7.1.1.Final instance running. Arquillian will connect to JBoss AS in order to magically flip through the pages. The result of the test will appear as normal in your JUnit view.

!/images/guides/arquillian_drone_tutorial_junit_green_bar.png!

*Congratulations!* You've just tested, that your application login page works correctly in Firefox! *(greenbar)Green bar*!

You can also run the test on the command line using Maven:

bc(command). $ mvn test -Pfirefox

p. You don't get a pretty green bar, but you should have seen Maven wrap up with no test failures or errors.

p(info). %The test works in Firefox, but what about another browser? Switching browsers is easy with the current setup, you just need to select the right maven profile. You also need to point Arquillian to the chrome driver, which you have downloaded from this "site":https://code.google.com/p/chromedriver/downloads/list. You will also need to specify @chromeDriverBinary@ into @pom.xml@.

p. In order to test your page without executing any real browsers, let's disable all profiles. Your test will run against headless PhantomJS browser, you have specified as default earlier.%

*Oh, wait!* But we haven't tested anything yet, we have just opened the page and have written text into text inputs.


h3. Defining the Test Logic

Let's define what we will actually test: when a user logs into into the application, he can use an AJAX widget which prints his name.

For that, we will need to describe all the elements which we can find on a tested pages:

bc(prettify).. // clip
@FindBy                                     // 1. injects an element by default location strategy ("idOrName")
private WebElement userName;

@FindBy
private WebElement password;

@FindBy(id = "login")
private WebElement loginButton;

@FindBy(tagName = "li")                     // 2. injects a first element with given tag name
private WebElement facesMessage;

@FindByJQuery("p:visible")                  // 3. injects an element using jQuery selector
private WebElement signedAs;

@FindBy(css = "input[type=submit]")
private WebElement whoAmI;
// clip

p. As you can see, we use @@FindBy@ annotation again to inject more elements. However, now we specify how to locate the element in more detail.

p. There are number of strategies how to locate an element on the tested page, and you should always prefer the most effective way:

* @@FindBy(id = "id")@ - fastest strategy
* @@FindBy(css = "selector")@ - CSS selectors (uses DOM method @querySelectorAll()@), familiar to web developers
* @@FindByJQuery("selector")@ - jQuery selectors are CSS selectors syntax with powerful extensions

p(info). %If you don't specify the location strategy, you will use the default one: finding elements by their ID or name. In this case you don't have to specify String as a @@FindBy@ parameter.%

p. Once you have described the page structure, you can use DOM elements to manipulate the page:

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
@Test
public void should_login_successfully() {
    browser.get(deploymentUrl.toExternalForm() + "login.jsf");

    userName.sendKeys("demo");
    password.sendKeys("demo");

    loginButton.click();
    assertEquals("Welcome", facesMessage.getText().trim());

    whoAmI.click();
    assertTrue(signedAs.getText().contains("demo"));
}
// clip

p. You can now run the test again: *(redbar)Red bar*

p. *Ah, what happened?!* If you weren't lucky (as I wasn't), you got a failure.

p. The problem which you might run into, is one of the tedious issues during Selenium test: every action you instruct the browser to do, might lead into an update of the page state.

p(info). %As you will experience, most of the actions on the AJAX-enabled pages don't block the Selenium execution. In the end, you will need to synchronize almost all the page interactions. In fact, in order to be sure the tests weren't fail intermitently no matter where they run, you should synchronize each manipulation with the page. Only that way you will ensure reproducibility.%

p(important). %You should forget about using delays as a method of synchronization in your tests. The poorly written test can run on your development machine but it can simply fail in more problematic environments.%

p. Graphene takes this challenge seriously, and allows you to cope with it as simple as possible.

p. There is Graphene's way how to concisely synchronize a page state:

bc(prettify).. // clip
browser.get(deploymentUrl.toExternalForm() + "login.jsf"); // first page load doesn't have to be synchronized

userName.sendKeys("demo");
password.sendKeys("demo");

guardHttp(loginButton).click();                            // 1. synchronize full-page request
assertEquals("Welcome", facesMessage.getText().trim());

guardAjax(whoAmI).click();                                 // 2. synchronize AJAX request
assertTrue(signedAs.getText().contains("demo"));
// clip

p. *That's it!* It is necessary to just wrap two page interactions!

p. When we click on the login button (*step 1*), we are re-locating to another page, so we are using "Request Guards":https://docs.jboss.org/author/display/ARQGRA2/Request+Guards to wait until the full-page update ends.

p. Then we click on a button which discovered user's name, and we guard AJAX request - the test won't continue until the page is fully updated as a consequence of an AJAX request.

p. Let's run the test again: *(greenbar)Green bar*

p. We were able to improve the test, so that no matter on how slow or resource-limited machine your test will run, it will always deterministically verify the web page logic.

p(info). %Sometimes you will run into situations where Request Guards can't help you. In this case you can always use precise Waiting API - it allows you to describe conditions on which the test should wait precisely and concisely.%

The situations where the Request guards API or implicit waiting won't help you:

* the page is updated without any prior server interaction
* JavaScript updates the pages once the request ends
* HTTP redirects

p. For the matter of completeness, know how you could refactor the test when Request Guards don't help:

bc(prettify).. // clip
browser.get(deploymentUrl.toExternalForm() + "login.jsf");

userName.sendKeys("demo");
password.sendKeys("demo");

waitModel().until().element(facesMessage).is().present();     // once the element is present, page is loaded
assertEquals("Welcome", facesMessage.getText().trim());

guardAjax(whoAmI).click();
waitAjax().until().element(signedAs).text().contains("demo"); // use condition as an assertion
// clip

p. Let's use the Request Guards where you can, as they are simplest synchronization API. Use Waiting API elsewhere.

h3. Abstract the Pages and their Fragments

p. As you would continue to author new tests as an application grows, it will quickly become apparent that you need to tame the size of a growing functional test suite.

p(important). %Huge functional test suite without a proper structure might become a maintainance nightmare.%

p. It is possible that your bell already started to ring, when you read the logic of a test defined before:

* it's mixing elements for two pages into one test class
* as each action in application needs to be authorized, tests will need to go through login action repeatedly

These are exactly the cases where Graphene might help you to give the test proper structure.

Let's start with separating the tests into two pages: a login page and a home page:

div(filename). src/test/java/org/arquillian/example/LoginPage.java

bc(prettify).. //clip
package org.arquillian.example;

import static org.jboss.arquillian.graphene.Graphene.guardHttp;

import org.jboss.arquillian.graphene.enricher.findby.FindBy;
import org.jboss.arquillian.graphene.spi.annotations.Location;
import org.openqa.selenium.WebElement;

@Location("login.jsf")
public class LoginPage {

    @FindBy
    private WebElement userName;

    @FindBy
    private WebElement password;

    @FindBy(id = "login")
    private WebElement loginButton;
    
    public void login(String userName, String password) {
        this.userName.sendKeys(userName);
        this.password.sendKeys(password);
        guardHttp(loginButton).click();
    }
}
//clip

p. Notice how the page encapsulates a location of the home page using @@Location@ annotation. It is basically a bookmark for the tests.

p. Now a class for the home page:

div(filename). src/test/java/org/arquillian/example/HomePage.java

bc(prettify).. //clip
package org.arquillian.example;

import org.jboss.arquillian.graphene.enricher.findby.FindBy;
import org.openqa.selenium.WebElement;

public class HomePage {

    @FindBy(tagName = "li")
    private WebElement facesMessage;

    @FindBy(jquery = "#whoami p:visible")
    private WebElement signedAs;

    @FindBy(css = "input[type=submit]")
    private GrapheneElement whoAmI;

    public void assertOnHomePage() {
        assertEquals("We should be on home page", "Welcome", getMessage());
    }
    
    public String getMessage() {
        return facesMessage.getText().trim();
    }

    public String getUserName {
        if (!signedAs.isPresent()) {
          whoAmI();
        }
        return signedAs.getText();
    }

    private void whoAmI() {
        guardAjax(whoAmi).click();
    }
}
//clip

p. Since we have abstracted the pages into own classes, we are now able to thoroughly simplify the test:

div(filename). src/test/java/org/arquillian/example/HomePage.java

bc(prettify).. //clip
import org.jboss.arquillian.graphene.spi.annotations.Page;

@Page
private HomePage homePage;

@Test
public void should_login_successfully( @InitialPage LoginPage loginPage ) {

   loginPage.login(USER_NAME, USER_PASSWORD);
   homePage.assertOnHomePage();

   assertTrue(homePage.getUserName(), USER_NAME);
}
//clip

p. Run the tests and again... *(greenbar)Green Bar*

p. Awesome! Page Objects pattern has been applied.

p. Graphene initializes the page objects wherever it sees a @Page@ annotation. In a special case it injects an @InitialPage@ which looks into the page object class for @Location@ annotation and loads it in the browser automatically.

p(info). %What is the added value of this refactoring? Tests are decoupled from the HTML code, so they are more readable. Introduction of a change to the application would be less error prone as tests are more robust.%

p. But that's not where our refactoring ends.

p. In our use case, we have just one login form. But some applications provides the same login form on various pages, so they can navigate visitors to authenticated areas. They could also define more than one form on one page! How to avoid those duplications?

p. Fortunately Graphene provides you "Page Fragments":https://docs.jboss.org/author/display/ARQGRA2/Page+Fragments pattern - Page Fragments allow you to encapsulate small reocurring pieces of pages to reusable abstractions.

p(info). %The typical example of page fragments might be widgets: styled and driven by scripts they usually give our pages interactivity that our users needs for fluent use of an application.%

p. Let's create new class @LoginForm@. Populate it with the same code which was in the @LoginPage@:

div(filename). src/test/java/org/arquillian/example/LoginForm.java

bc(prettify).. //clip
public class LoginForm {

    @Root
    private WebElement form;

    @FindBy(css = "input[type=text]")
    private WebElement userName;

    @FindBy(css = "input[type=password]")
    private WebElement password;

    @FindBy(css = "input[type=submit]")
    private WebElement loginButton;
    
    public void login(String userName, String password) {
        this.userName.sendKeys(userName);
        this.password.sendKeys(password);
        guardHttp(loginButton).click();
    }
}

p. We got a general enough implementation of LoginForm, just few differences here:

p. Notice that we have changed locators to use CSS selectors - we can't use ID locators since there can't be two login forms which contains inputs with same IDs.

p. Additionally we have defined @@Root@ element, which serves as a root of the page fragment (or widget) on a page. Let's use the fragment in a page so we can understand the case better:

div(filename). src/test/java/org/arquillian/example/LoginPage.java

bc(prettify).. //clip
@Location("login.jsf")
public class LoginPage {

    @FindBy
    private LoginForm loginForm;        // locates the root of a page fragment in particular page
    
    public LoginForm getLoginForm() {   // we can either manipulate with login form or just expose it
       return loginForm;
    }
}
//clip

p. Notice the same mechanism of locating Page Fragments as you have seen for @WebElement@ fields. The usage of such page fragment in the test is pretty straightforward.

_Arquillian makes integration testing a breeze. Arquillian Drone adds a great support for functional tests. Together, they make developing tests fun again._

If you are looking for more Graphene goodness, be sure to check "Graphene Reference Documentation":https://docs.jboss.org/author/display/ARQGRA2/Home.

p(info). %This tutorial really isn't the fastest way how to develop functional tests, but the goal of this guide is just teach you the basics. You can refer to tips & tricks how to achieve "rapid test development turnaround":http://lukas.fryc.eu/blog/2013/06/testing-jsf-richfaces-arquillian-2-rapid-test-development.html.%

p(info). %Even though this guide follows best practices to manage Graphene, including few tricks for allowing continuous integration, you should really "get know more if you thrives to achieve good coverage":http://lukas.fryc.eu/blog/2013/06/testing-jsf-richfaces-arquillian-4-continous-integration.html, and guard your test against regressions across multiple browsers.%
