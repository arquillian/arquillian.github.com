---
layout: guide
title: Functional Testing using Graphene
authors: [mojavelinux, kpiwko, jhuska]
tags: [graphene, drone, selenium, as7]
description: Discover how Arquillian Graphene simplifies testing the web UI of your application.
guide_group: 2
guide_order: 3
---
This guide introduces you to the Arquillian Graphene (Selenium 2 on steroids) extension. After reading this guide, you'll be able to:

* Add the Graphene extension to your Arquillian-based test suite
* Package portions of your web application to test the web user interface (UI)
* Inject the Graphene 2 API into your test case
* Control the browser using Graphene 2 to validate the behavior of your web application
* Use the best practices for developing and running Graphene tests in a reliable and fast way

You'll appreciate how much heavy lifting Graphene is doing to perform automated functional testing!

h3. Assumptions

We'll assume that you've read the "Getting Started":/guides/getting_started guide and have an Arquillian test suite setup in your project. We'll be adding a simple JSF(JavaServer Faces) login form to the project as an example of a web UI to test. From there, you can apply these instructions to any other web pages you may need to test.

The instructions in this guide are specific to a Maven project, though remember that Arquillian is not tied to Maven in any way. We'll be running the tests on a JBoss AS 7 instance, though you can use any container supported by Arquillian that has a web container.

In this guide, we'll be using the following technologies:

* Arquillian
* Arquillian Drone
* Arquillian Graphene
 
All listed technologies are a part of Arquillian test platform. Both Arquillian Drone and Graphene are working with "Selenium":http://seleniumhq.org, which is in short technology for browsers automation. Arquillian Drone integrates Selenium framework with Arquillian and facilitates some of the tedious processes needed to test frontend of any web application. The Arquillian Graphene is built on top of Selenium 2 and adds tons of utilities for proper testing of WEB UI. You will see them in a minute!

If you are already familiar with Selenium, you'll discover that Arquillian manages the Selenium Server life cycle in much the same way it manages the container life cycle. If Selenium is new to you, this is a great opportunity to begin using its enhanced version Graphene to test the web UI of your application without having to worry about how it's setup.

h3. Introducing Client Mode

If you'd ever written an Arquillian based test, you know that it looks almost the same as a unit test for the unit testing framework you are using. Let's look at an example of an Arquillian test that uses JUnit:

bc(prettify).. @RunWith(Arquillian.class)
public class BasicInContainerTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(MyBean.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }
    
    @Inject
    MyBean bean;
 
    @Test
    public void should_inject_bean_instance() {
        Assert.assertNotNull(bean);
    }
}

p. Here we've deployed a CDI bean to the server inside a bean archive. In the test, we've injected the instance of the bean, then asserted that the injection has occurred. Arquillian first enriches the archive with the test infrastructure. It then connects to the server to deploy the archive and execute the test method inside of the container by launching the JUnit test runner a second time inside that environment. Finally, Arquillian retrieves the results from that remote execution. This example demonstrates the default run mode of Arquillian: in-container. In a sense, the local JUnit runner is a client of the container, being driven by Arquillian.

The other run mode in Arquillian is the client run mode. In this mode, Arquillian deploys the test archive as is to the server. It then allows the tests to run in the same JVM as the test runner. Now your test case is a client of the container. The test no longer runs inside the container, yet Arquillian still handles the life cycle of the container as well as deployment of the test archive. It's the ideal mode for web UI testing.

h3. Enabling Client Mode

How do you activate client mode? Quite simply. You either mark a deployment as non-testable, meaning Arquillian will not enrich the archive, or you can mark a specified method with the annotation @@RunAsClient@. Here's an example:

bc(prettify).. @RunWith(Arquillian.class)
public class BasicClientTest {
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return ShrinkWrap.create(WebArchive.class)
            .addClasses(MyBean.class)
            .setWebXML("WEB-INF/web.xml");
    }
    
    @Test
    public void should_login_successfully() {
    }
}

p. It's also possible to mix in-container and client modes in the same test! Just leave off the @testable@ attribute. Any method annotated with @@RunAsClient@ will execute from the client, the remainder will execute inside the container, giving you the best of both worlds!

bc(prettify).. @RunWith(Arquillian.class)
public class MixedRunModeTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(MyBean.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }
    
    @Inject
    MyBean bean;
 
    @Test
    public void should_run_in_container() {
        // executed from the server JVM
        Assert.assertNotNull(bean);
    }

    @Test
    @RunAsClient
    public void should_run_as_client() {
        // executed from the client JVM
    }
}

p. Now that you understand how to run a test in client mode, let's check out how to test a web UI by using Arquillian Graphene to drive your browser.

h3. Graphene Overview

Arquillian Graphene is a set of extensions for "Selenium 2":http://docs.seleniumhq.org project, focused on rapid development and usability in Java environment. Its API enables people to write tests for AJAX-based web applications more conveniently, and more importantly in a robust way. Graphene strives for reusable tests by encouraging people to use reasonable abstraction and testing patterns ("Page Objects":https://docs.jboss.org/author/display/ARQGRA2/Page+Objects and "Page Fragments":https://docs.jboss.org/author/display/ARQGRA2/Page+Fragments).

Arquillian Graphene project with its features fills the gaps in functional testing of your web application. The short list of the most interesting additions together with above mentioned is: improved "waiting API":https://docs.jboss.org/author/display/ARQGRA2/Graphene+Utility+Class#GrapheneUtilityClass-Waitings, "request guarding":https://docs.jboss.org/author/display/ARQGRA2/Request+Guards, WebDriver API "interception":https://docs.jboss.org/author/display/ARQGRA2/Graphene+Interceptors, portability across browsers, "JQuery locating":https://docs.jboss.org/author/display/ARQGRA2/Graphene+FindBy+annotation strategy, injecting of an "extension":https://docs.jboss.org/author/display/ARQGRA2/Page+Extensions to a page code and lot more.

It depends on Arquillian Drone, which is an extension that manages the life cycle of testing browsers for the purpose of simplifying automated functional testing.
 
Currently, the list of supported browsers is pretty large, a bounded set of those covered by Selenium Server, Selenium Core, Selenium WebDriver and Arquillian Graphene (e.g. Firefox, Chrome, IE, Opera, PhantomJS and HTMLUnit for headless testing). Like Arquillian Core, the Arquillian Graphene and  Arquillian Drone extensions are, well, pretty extensible. If your favorite browser is not supported, you'll find it easy to add the support.
  
Let's get Arquillian Graphene configured so that we can start writing some tests.

p(info). %For more information about how Drone can enable you Selenium 1 testing, or testing in the mobile environment, check out its "reference documentation":https://docs.jboss.org/author/display/ARQ/Drone.%

h3. Set Up Graphene

Let's start by setting up the libraries in the Maven pom.xml file that we need to use the Graphene extension. As with the previous tutorials, we need to instruct Maven which versions of the artifacts to use by importing a BOM(Bill of Materials), or version matrix. If you followed the getting started guide, you should already have a BOM defined for Arquillian in the @<dependencyManagement>@ section.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian</groupId>
            <artifactId>arquillian-bom</artifactId>
            <version>1.0.4.Final</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
<!-- clip -->

p. Below that @<dependency>@, add another entry for defining the version matrix for Drone's transitive dependencies, leaving you with the following result:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian</groupId>
            <artifactId>arquillian-bom</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.arquillian.extension</groupId>
            <artifactId>arquillian-drone-bom</artifactId>
            <version>1.2.0.Alpha2</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
<!-- clip -->

p. If you've set up Arquillian previously, you should already have the JUnit and Arquillian JUnit integration dependencies under @dependencies@ element.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>org.jboss.arquillian.junit</groupId>
        <artifactId>arquillian-junit-container</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <scope>test</scope>
        <version>4.8.1</version>
    </dependency>
</dependencies>
<!-- clip -->

p. Next, add the Graphene dependency, which brings you all the other required dependencies:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.graphene</groupId>
    <artifactId>graphene-webdriver</artifactId>
    <version>2.0.0.Alpha5</version>
    <type>pom</type>
    <scope>test</scope>
</dependency>
<!-- clip -->


p. You have to specify the dependency on a container adapter. We'll use the JBoss AS 7 remote container since we would like to showcase you the fast turnaround you should appreciate while developing tests. You would use a managed one when testing in a continous integration environment.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.as</groupId>
    <artifactId>jboss-as-arquillian-container-remote</artifactId>
    <version>7.1.1.Final</version>
    <scope>test</scope>
</dependency>
<!-- clip -->

p(important). %If you are testing against multiple containers, then the container adapter should be included in a dedicated profile, as described in the "Getting Started":/guides/getting_started guide.%

p. You typically need to test your web application across different browsers. Let's add a uniform way of choosing which browser you are testing on to the @pom.xml@. Firstly, create profile for each desired browser.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profiles>
    <profile>
       <id>firefox</id>
       <properties>
          <browser.capabilities>firefox</browser.capabilities>
       </properties>
    </profile>
    <profile>
       <id>chrome</id>
       <properties>
           <browser.capabilities>chrome</browser.capabilities>
       </properties>
    </profile>
</profiles>
<!-- clip -->

p. Secondly, you need to set the right system property in order to effectively change the Arquillian settings for browser selection. Add following to the @pom.xml@:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<build>
  <plugins>
    <plugin>
      <artifactId>maven-surefire-plugin</artifactId>
      <configuration>
        <systemProperties>
          <arq.extension.webdriver.browserCapabilities>${browser.capabilities}</arq.extension.webdriver.browserCapabilities>
        </systemProperties>
      </configuration>
    </plugin>
  </plugins>
</build>
<!-- clip -->

h3. Create a Login Screen

When writing a web UI test, you have to make sure you deploy a complete web application, even if it's only a fraction of your full application (e.g., a micro application). Therefore, the @@Deployment@ method for these types of tests is going to be a bit more complex, but don't let it turn you off. Over time, you'll divide up the deployment into reusable parts to trim down the configuration on a per-test basis.

To create the login screen of the application, we need the following files and resources:

# Credentials bean to capture the username and password
# User bean to represent the current user
# Login controller to authenticate the user and produce the current user
# Login page
# Home page (landing page after successful login)

If you haven't done so already, open the project in your IDE. Next, create a @Credentials@ class in the @org.arquillian.example@ package.

div(filename). src/main/java/org/arquillian/example/Credentials.java

bc(prettify).. package org.arquillian.example;

import javax.enterprise.inject.Model;

@Model
public class Credentials {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

p. @Credentials@ is a request-scoped, named bean (as indicated by the @@Model@ stereotype annotation) to make it capable of capturing data from the JSF login form we are going to create.

Next, create the @User@ class in the same package. In a more advanced example, this class would likely serve as a JPA entity, able to retrieve the user's information from a database. For now, we'll stick with a more basic use case.

div(filename). src/main/java/org/arquillian/example/User.java

bc(prettify).. package org.arquillian.example;

public class User {
    private String username;

    public User() {}
    
    public User(String username) {
        this.username = username;
    }
    
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }
}

p. Next up, create the @LoginController@ class, again in the same package. For the purpose of this example, this implementation only accepts a username and password of "demo" and issues a welcome message when the login is successful.

div(filename). src/main/java/org/arquillian/example/LoginController.java

bc(prettify).. //clip
package org.arquillian.example;

import java.io.Serializable;

import javax.enterprise.context.SessionScoped;
import javax.enterprise.inject.Produces;
import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;
import javax.inject.Inject;
import javax.inject.Named;

@Named
@SessionScoped
public class LoginController implements Serializable {
    private static final long serialVersionUID = 1L;

    private static final String SUCCESS_MESSAGE = "Welcome";
    private static final String FAILURE_MESSAGE =
        "Incorrect username and password combination";

    private User currentUser;
    private boolean renderedLoggedIn = false;
    
    @Inject
    private Credentials credentials;
    
    public String login() {
        if ("demo".equals(credentials.getUsername()) &&
            "demo".equals(credentials.getPassword())) {
            currentUser = new User("demo");
            FacesContext.getCurrentInstance().addMessage(null,
                new FacesMessage(SUCCESS_MESSAGE));
            return "home.xhtml";
        }

        FacesContext.getCurrentInstance().addMessage(null,
            new FacesMessage(FacesMessage.SEVERITY_WARN,
                FAILURE_MESSAGE, FAILURE_MESSAGE));
        return null;
    }
    
    public boolean isRenderedLoggedIn() {
        if(currentUser != null) {
            return renderedLoggedIn;
        } else {
            return false;
        }
    }
    
    public void renderLoggedIn() {
        this.renderedLoggedIn = true;
    }
    
    @Produces
    @Named
    public User getCurrentUser() {
        return currentUser;
    }
}
//clip

p. The @LoginController@ is session-scoped so that it can store the current user for the duration of the user's session and named so that it can be accessed by the action button on the login form.

Finally, we need to create the UI screens. In the @src/main/webapp@ directory, create a login page:

div(filename). src/main/webapp/login.xhtml

bc(prettify).. <!-- clip -->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ui="http://java.sun.com/jsf/facelets"
    xmlns:h="http://java.sun.com/jsf/html"
    xmlns:f="http://java.sun.com/jsf/core">
    <head>
        <title>Log in</title>
    </head>
    <body>
        <h:messages/>
        <h:form id="loginForm">
            <h:panelGrid columns="2">
                <h:outputLabel for="userName">Username:</h:outputLabel>
                <h:inputText id="userName" value="\#{credentials.username}"/>
                <h:outputLabel for="password">Password:</h:outputLabel>
                <h:inputSecret id="password" value="\#{credentials.password}"/>
                <h:commandButton id="login" value="Log in"
                    action="\#{loginController.login}"/>
            </h:panelGrid>
        </h:form>
    </body>
</html>
<!-- clip -->

p. and a home page:

div(filename). src/main/webapp/home.xhtml

bc(prettify).. <!-- clip -->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
 xmlns:ui="http://java.sun.com/jsf/facelets"
	xmlns:h="http://java.sun.com/jsf/html"
	xmlns:f="http://java.sun.com/jsf/core">
<h:head>
	<title>Home</title>
</h:head>
<h:body>
	<h:messages />
	<h:form>
		<h:commandButton value="Who Am I ?" action="#{loginController.renderLoggedIn}">
			<f:ajax render="whoami" />
		</h:commandButton>
		<h:panelGroup id="whoami">
			<h:panelGroup rendered="#{loginController.renderedLoggedIn}">
				<p>You are signed in as #{currentUser.username}.</p>
			</h:panelGroup>
		</h:panelGroup>
	</h:form>
</h:body>
</html>
<!-- clip -->

p. Now we need to write a test to see if these components come together to produce a functioning login screen.

h3. Create a Test Archive

Here's the shell of a test case for testing the logic screen with just the @@Deployment@ method in place. All the files all listed explicitly to illustrate what's being included.

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. package org.arquillian.example;

import java.io.File;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.asset.StringAsset;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class LoginScreenGrapheneTest {
    private static final String WEBAPP_SRC = "src/main/webapp";
    
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return ShrinkWrap.create(WebArchive.class, "login.war")
            .addClasses(Credentials.class, User.class, LoginController.class)
            .addAsWebResource(new File(WEBAPP_SRC, "login.xhtml"))
            .addAsWebResource(new File(WEBAPP_SRC, "home.xhtml"))
            .addAsWebInfResource(EmptyAsset.INSTANCE, "beans.xml")
            .addAsWebInfResource(
                new StringAsset("<faces-config version=\"2.0\"/>"),
                "faces-config.xml");
    }
}

p(important). %Don't forget to set @testable = false@ attribute on the @@Deployment@ annotation to enable client mode.%

p(warning). %The Java EE 6 specification requires a @faces-config.xml@ descriptor to be present in WEB-INF to activate JSF. Unlike @beans.xml@, however, the @faces-config.xml@ descriptor cannot be an empty file. It must contain at least the root node and the version attribute to specify the JSF version in use.%

p. If you have a lot of web pages that are part of the test, having to add them to the archive individually is tedious. Instead, you can import them in bulk using the @ExplodedImporter@ from ShrinkWrap. Here's an example of how to add all the web sources that end in .xhtml to the archive:

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
import org.jboss.shrinkwrap.api.Filters;
import org.jboss.shrinkwrap.api.GenericArchive;
import org.jboss.shrinkwrap.api.importer.ExplodedImporter;
// clip

return ShrinkWrap.create(WebArchive.class, "login.war")
    .addClasses(Credentials.class, User.class, LoginController.class)
    .merge(ShrinkWrap.create(GenericArchive.class).as(ExplodedImporter.class)
        .importDirectory(WEBAPP_SRC).as(GenericArchive.class),
        "/", Filters.include(".*\\.xhtml$"))
    .addAsWebInfResource(EmptyAsset.INSTANCE, "beans.xml")
    .addAsWebInfResource(
        new StringAsset("<faces-config version=\"2.0\"/>"),
        "faces-config.xml");

// clip

p. For more information about how to use @ExplodedImporter@ for this task, and alternative strategies, see "this FAQ":https://community.jboss.org/wiki/HowDoIAddAllWebResourcesToTheShrinkWrapArchive.

p. One way to trim this down is to move the creation of the archive to a utility class and refer to it whenever you need this particular micro application. That leaves you with a much simpler @@Deployment@ method:

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
@RunWith(Arquillian.class)
public class LoginScreenGrapheneTest {
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return Deployments.createLoginScreenDeployment();
    }
}

p. Now let's get a handle on Graphene.

h3. Inject the Graphene API

Graphene builds on top of @WebDriver@ API (Selenium 2). @WebDriver@ API calls are intercepted and enhanced with a desired functionality. Let's start with injecting well know @WebDriver@ object.

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
import org.jboss.arquillian.drone.api.annotation.Drone;
import org.openqa.selenium.WebDriver;
// clip

@RunWith(Arquillian.class)
public class LoginScreenGrapheneTest {
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return Deployments.createLoginScreenDeployment();
    }

    @Drone
    WebDriver browser;
}

p. *That's it!* The @@Drone@ injection point tells Drone to create an instance of the browser controller, "WebDriver":http://selenium.googlecode.com/git/docs/api/java/index.html, before the first client test is run, then inject that object into the test case.

*Oh wait!* There's one more thing. We're testing web UI, but how do we know the URL of deployed application? Well, Arquillian already has a solution. Just use @@ArquillianResource@ to inject the URL of the deployed application.

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
import java.net.URL;
import org.jboss.arquillian.test.api.ArquillianResource;
// clip

@RunWith(Arquillian.class)
public class LoginScreenGrapheneTest {
    @Deployment(testable = false)
    public static WebArchive createDeployment() {
        return Deployments.createLoginScreenDeployment();
    }

    @Drone
    WebDriver browser;

    @ArquillianResource
    URL deploymentUrl;
}

p. Now even the URL of your deployed archive is injected in the test. It's now time to drive the browser to verify the functionality of the web application.

h3. Drive the Browser

Here's the test method that pokes at the login screen to make sure it works. We use Graphene to verify that the welcome message appears after a successful login.

div(filename). src/test/java/org/arquillian/example/LoginScreenGrapheneTest.java

bc(prettify).. // clip
import static org.jboss.arquillian.graphene.Graphene.guardHttp;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import org.jboss.arquillian.graphene.enricher.findby.FindBy;
import org.openqa.selenium.WebElement;

@FindBy
private WebElement userName;

@FindBy
private WebElement password;

@FindBy(id = "login")
private WebElement loginButton;

@FindBy(tagName = "li")
private WebElement facesMessage;

@FindBy(jquery = "p:visible")
private WebElement signedAs;

@FindBy(jquery="input[type=submit]")
private WebElement whoAmI;

@Test
public void should_login_successfully() {
    browser.get(deploymentUrl.toExternalForm() + "login.jsf");

    userName.sendKeys("demo");
    password.sendKeys("demo");

    guardHttp(loginButton).click();

    assertEquals("Welcome", facesMessage.getText().trim());
    whoAmI.click();
    waitAjax().until().element(signedAs).is().present();
    assertTrue(signedAs.getText().contains("demo"));
}
// clip

p. Elements from the page are wired with the tests via @FindBy@ annotations. Graphene comes with its own implementation, which is a derivation from WebDriver "FindBy":http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/support/FindBy.html. This enhanced version adds support for JQuery selectors (see @signedAs@ field). Have a look also on fields @userName@ and @password@. They are not defining the locating strategy, thus Graphene will use their fields names as values for @idOrName@ locating strategy. All @WebElement@ instances are injected properly initialized, so you can just easily use them in your tests. 

p. Next used feature is @guardHttp@ method. This one particularly will ensure that a full HTTP request will be fired once the @loginButton@ is clicked. If not, an exception is thrown. What is nice is that it will blocks until the HTTP request is done, giving you a powerful method of waiting for "Welcome" message being rendered.

p. Last noticeable Graphene's feature is fluent API for waiting. See @waitAjax().until().element(signedAs).is().present();@. Isn't it far more readable than classic @WebDriver@ wait condition ? It is also more robust than usual waiting method, because it does not set how long it should wait explicitly. You can set this value globally for all @waitAjax@ conditions. So you will never experience different results when running the test on the local machine and in your continuous integration environment.

p. Before you will run the test in your IDE, we are going to add the last piece in the fast-turnaround story. The feature is called remote-reusable browsers. It enables you to reuse the browser session for multiple tests, which saves you a significant amount of time by not starting and killing the browser for each test. To achieve this you need to add following snippets into your @pom.xml@

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<project>
  <properties>
    <arquillian.drone.reusable>false</arquillian.drone.reusable>
  </properties>

  <build>
    <testResources>
      <testResource>
        <directory>src/test/resources</directory>
        <filtering>true</filtering>
      </testResource>
    </testResources>
    <plugins>
      <plugin>
        <artifactId>maven-surefire-plugin</artifactId>
        <configuration>
          <systemProperties>
            <arq.extension.webdriver.browserCapabilities>${browser.capabilities}</arq.extension.webdriver.browserCapabilities>
            <arq.extension.webdriver.remoteReusable>${arquillian.drone.reusable}</arq.extension.webdriver.remoteReusable>
          </systemProperties>
        </configuration>
      </plugin>
    </plugins>
  </build>

  <profiles>
    <profile>
      <id>browser-remote-reusable</id>
      <properties>
        <arquillian.drone.reusable>true</arquillian.drone.reusable>
      </properties>
    </profile>
  </profiles>
</project>
<!-- clip -->

p. Previous lines give you a way how to change the browser based on the selected maven profile. Create the Arquillian descriptor, arquillian.xml, under the @src/test/resources@ folder and populate it with the following content:

div(filename). src/test/resources/arquillian.xml

bc(prettify).. <!-- clip -->
<?xml version="1.0"?>
<arquillian xmlns="http://jboss.com/arquillian" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://jboss.org/schema/arquillian http://jboss.org/schema/arquillian/arquillian_1_0.xsd">

    <extension qualifier="webdriver">
        <property name="browserCapabilities">${browser.capabilities}</property>
        <property name="remoteReusable">${arquillian.drone.reusable}</property>
        <property name="remoteAddress">http://localhost:4444/wd/hub/</property>
    </extension>
</arquillian>
<!-- clip -->

p. Because you are going to use remote browser, you will need to start selenium server by yourselves. Download the latest @selenium-server-standalone.jar@ from "here":https://code.google.com/p/selenium/downloads/list and start it. By default it should start listening on the address @http://127.0.0.1:4444/wd/hub@, which is the one you have defined in the @arquillian.xml@.

p. Finally you are able to run the test! Choose the @firefox@ and the @browser-remote-reusable@ for you project in your IDE (CTRL + P hotkey in Eclipse).
Right click on the test in your IDE and select Run As > JUnit test. Do not forget to have JBoss AS 7.1.1.Final instance running. Arquillian will connect to both JBoss AS and selenium server in order to magically flip through the pages. The result of the test will appear as normal in your JUnit view.

!/images/guides/arquillian_drone_tutorial_junit_green_bar.png!

*Congratulations!* You've just tested that your application login page works correctly in Firefox! Try to rerun the test again with remote-reusable switched off, and see the difference. *(greenbar)Green bar*!

You can also run the test on the commandline using Maven:

bc(command). $ mvn test -Pfirefox,browser-remote-reusable

p. You don't get a pretty green bar, but you should have seen that the same Firefox instance is being used for the very same test, then Maven wrap up with no test failures or errors.

The test works in Firefox, but what about another browser, like Google Chrome? Switching browsers is easy, with the current setup you just need to select the right maven profile. You also need to point Arquillian to the chrome driver, which you have downloaded from this "site":https://code.google.com/p/chromedriver/downloads/list. Add following line to the @arquillian.xml@:

bc(prettify).. <!-- clip -->
<extension qualifier="webdriver">
  <property name="browserCapabilities">${browser.capabilities}</property>
  <property name="remoteReusable">${arquillian.drone.reusable}</property>
  <property name="remoteAddress">http://localhost:4444/wd/hub/</property>
  <property name="chromeDriverBinary">path/to/chromedriver</property>
</extension>

p. Now run the tests again. *(greenbar)Green bar*! This time, you'll notice that Arquillian launched Google Chrome instead of Firefox. Now you've got two browsers covered.

p. Did the test go by too fast? One way to slow it down is to use a breakpoint in the test and run it in debug mode.

h3. Pause the Test

If you want to see what's happening in the browser while the test is running, one way tap on the breaks is to add a breakpoint to the test and run it in debug mode. Open up the @LoginScreenGrapheneTest@ class and add a breakpoint on the line that performs the click on the login button. Then, right click and select Debug As > JUnit Test. The test should pause when it gets to the breakpoint as shown in the screenshot below:

!/images/guides/arquillian_drone_tutorial_debug_test.png!

If you switch over to the browser, you should see the browser waiting on the login screen:

!/images/guides/arquillian_drone_tutorial_login_screen.png!

Consider using Chrome for debugging, as you can use its developer tools to inspect the page source, network activity or for debugging JavaScript.
When you are ready to continue the automation, simply press the continue (play) button in the debugger.

h3. Extending the test suite

p. One test for a big application probably would not be enough. Massive functional web UI test suite can cause you nightmares though. Such tests are usually costly to maintain, due to their bad readability and lack of robustness.

p. These are challenges Graphene is trying to cope with, and this is where Graphene is strong!

p. Let's apply some of the good practices to the previous test. First objection, what an experienced tester may have, is a tightly coupled test code with the HTML code of the tested application. We should change it!

p. Firstly, we are going to apply "Page Object":https://docs.jboss.org/author/display/ARQGRA2/Page+Objects pattern. Our application consists from two pages. Create under the same package class with name @LoginScreenPage@.

div(filename). src/test/java/org/arquillian/example/LoginScreenPage.java

bc(prettify).. //clip
package org.arquillian.example;

import static org.jboss.arquillian.graphene.Graphene.guardHttp;

import org.jboss.arquillian.graphene.enricher.findby.FindBy;
import org.jboss.arquillian.graphene.spi.annotations.Location;
import org.openqa.selenium.WebElement;

@Location("login.jsf")
public class LoginScreenPage {

    @FindBy
    private WebElement userName;

    @FindBy
    private WebElement password;

    @FindBy(id = "login")
    private WebElement loginButton;
    
    public void setUserName(String userName) {
        this.userName.sendKeys(userName);
    }
    
    public void setPassword(String password) {
        this.password.sendKeys(password);
    }
    
    public void login() {
        guardHttp(loginButton).click();
    }
}
//clip

p. Now a class for the home page.

div(filename). src/test/java/org/arquillian/example/HomePage.java

bc(prettify).. //clip
package org.arquillian.example;

import org.jboss.arquillian.graphene.enricher.findby.FindBy;
import org.openqa.selenium.WebElement;

public class HomePage {

    @FindBy(tagName = "li")
    private WebElement facesMessage;

    @FindBy(jquery = "p:visible")
    private WebElement signedAs;

    @FindBy(jquery="input[type=submit]")
    private WebElement whoAmI;
    
    public String getMessage() {
        return facesMessage.getText().trim();
    }
    
    public boolean assertLoggedAs(String userName) {
        return signedAs.getText().contains(userName);
    }

    public void whoAmI() {
        whoAmI.click();
        waitAjax().until().element(signedAs).is().present();
    }
}
//clip

p. We are now ready to use created pages in the test. Alter the @LoginScreenGrapheneTest@, so it would look like:

div(filename). src/test/java/org/arquillian/example/HomePage.java

bc(prettify).. //clip
import org.jboss.arquillian.graphene.spi.annotations.Page;

@Page
private HomePage homePage;

@Test
public void should_login_successfully(@InitialPage LoginScreenPage loggScreenPage) {
   loggScreenPage.setUserName(USER_NAME);
   loggScreenPage.setPassword(PASSWORD);
        
   loggScreenPage.login();

   assertEquals("Welcome", homePage.getMessage());
   homePage.whoAmI();
   assertTrue(homePage.assertLoggedAs(USER_NAME));
}
//clip

p. Great! Page Objects pattern has been applied. What is the added value ? Tests are decoupled from the HTML code, meaning they are better readable. Thus introducing a change to such test would be less error prone, meaning tests are more robust!

p. Graphene helps you with initializing of your page objects. You can inject them similarly to the @WebElement@ fields, you should just use @Page@ annotation. Also notice that we have got rid of loading the page as the first line of the test. Instead we used @InitialPage@ annotation over the test parameter, together with @Location@ annotation over the page object class declaration. Graphene will take care of the loading the right page on the correct deployed URL as the first action in the test execution.

p. There is one more powerfull pattern. Imagine that you have quite similar login mechanism all over your applications. The same code for testing such login functionality will be repeated in all tests. That is ugly.

p. Fortunately Graphene provides you "Page Fragments":https://docs.jboss.org/author/display/ARQGRA2/Page+Fragments pattern support. Let's rework our test sample.

p. Create new class @LoginFragment@. Populate it basically with the same code which was in the @LoginScreenPage@. It looks like we are doing nothing, but imagine that there are much more components on the page.

p. Alter the @LoginScreenPage@ so it will contain the reference to the created @LoginFragment@

div(filename). src/test/java/org/arquillian/example/LoginScreenPage.java

bc(prettify).. //clip

@FindBy(id = "loginForm")
private LoginFragment loginFragment;
    
public LoginFragment getLoginFragment() {
   return loginFragment;
}
//clip

p. Notice the same mechanism of locating Page Fragments as you have seen for @WebElement@ fields. The usage of such page fragment in the test is pretty straightforward.

_Arquillian makes integration testing a breeze. Arquillian Drone adds a great support for functional tests. Together, they make developing tests fun again._
