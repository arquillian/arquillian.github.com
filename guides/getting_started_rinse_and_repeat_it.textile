---
layout: guide
title: "Guida introduttiva: Rispolveriamo e Ripetiamo"
authors: [mojavelinux]
translators: [flashboss]
description: Parte 2 della Guida Introduttiva. Rivediamo i nostri progressi esplorando un esempio più complesso e impariamo a usare container remoti.
guide_group: 1
guide_order: 20
TODO: ["port configuration and arquillian.launch", "expected deployment error"]
---
In questa seconda parte della "Guida introduttiva":/guides/getting_started guide, proseguiremo il lavoro visto su Arquillian esplorando un esempio leggermente più complesso- Terminata la lettura di questa guida saremo in grado di:

* Scrivere un test Arquillian che usa insieme CDI(Contexts and Dependency Injection) e EJB(Enterprise JavaBeans)
* Eseguire un test Arquillian in un container remoto
* Fare il debugging di un test dentro un container remoto

Per ottenere ciò, dobbiamo aggiungere dei nuovi profili al nostro build. Una volta attivi, permetteranno di usare Arquillian in un container remoto (p.es., application server). Testermo quindi la _situazione reale_ senza i mock. E a runtime! E dal momento che la maggiorparte del lavoro è stata fatta nella prima guida, non impiegheremo molto tempo a farlo.

h3. Prerequisiti

La guida richiede che sia già stata aggiunta l'infrastruttura di Arquillian nel progetto e che sia stato aggiunto ed eseguito almeno un test con Arquillian. Se non è ancora stato fatto, guardate prima la "Guida Introduttiva":/guides/getting_started per ottenere familiarità con le basi di Arquillian. Assicuratevi anche di avere già tutto il software menzionato in quella guida.

h3. Creare i Componenti

In questa guida, creeremo un backend molto basilare per un'applicazione di shopping. Useremo un componente carrello per registrare gli oggetti selezionati dal visitatore e un componente repository per registrare e ricevere gli ordini fatti. Implementeremo questi componenti usando CDI ed EJB rispettivamente. Possiamo iniziare subito usando questi due modelli dal momento che abbiamo già la Java EE 6 API nel classpath. (Riferitevi alla "Guida Introduttiva":/guides/getting_started per le istruzioni su come aggiungere queste API nel progetto).

Iniziamo con il componente che mette gli ordini nello storage di persistenza. Seguendo le best practice per scrivere un buon software, e per rendere più semplici i test, iniziamo a definire un'interfaccia di contratto. Nel nostro IDE, creiamo una nuova interfaccia locale per l'EJB chiamata @OrderRepository@ e popoliamola con i seguenti contenuti:

div(filename). src/main/java/org/arquillian/example/OrderRepository.java

bc(prettify).. package org.arquillian.example;

import java.util.List;
import javax.ejb.Local;

@Local
public interface OrderRepository {
    void addOrder(List<String> order);
    List<List<String>> getOrders();
    int getOrderCount();
}

p. Ci preoccuperemo dell'implementazione più tardi. Vediamo ora in che modo useremo il contratto.

Quando i visitatori navigheranno nel sito, dovranno poter fare le compere con il carrello. Per questo scenario, useremo un bean CDI associato alla sessione HTTP del visitatore. Questo componente delegherà le operazioni all'EJB @OrderRepository@ durante le compere.

Nel nostro IDE, creiamo una classe con nome @Basket@ e agganciamola al contesto della sessione tramite l'annotazione @@SessionScoped@, come mostrato in basso:

div(filename). src/main/java/org/arquillian/example/Basket.java

bc(prettify).. package org.arquillian.example;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.annotation.PostConstruct;
import javax.ejb.EJB;
import javax.enterprise.context.SessionScoped;

@SessionScoped
public class Basket implements Serializable {
    private static final long serialVersionUID = 1L;
    private List<String> items;
    
    @EJB
    private OrderRepository repo;
    
    public void addItem(String item) {
        items.add(item);
    }
    
    public List<String> getItems() {
        return Collections.unmodifiableList(items);
    }
    
    public int getItemCount() {
        return items.size();
    }
    
    public void placeOrder() {
        repo.addOrder(items);
        items.clear();
    }
    
    @PostConstruct
    void initialize() {
        items = new ArrayList<String>();
    }
}

p. Come si può vedere, abbiamo agganciato l'EJB a un bean CDI, precisamente l'integrazione che vogliamo testare!

h3. Fase di implementazione

Non possiamo ancora scrivere il test visto che ancora non abbiamo l'implementazione del @OrderRepository@.

Supponiamo che l'@OrderRepository@ è stato implementato da un'altro team (o in una fase differente). La funzionalità di micro-deploy di Arquillian sarà assolutamente estranea a questa parte. Possiamo per esempio creare un'implementazione in-memory sotto forma di singleton EJB e impacchetarlo nell'archivio di test per ottenere un'applicazione funzionante in brevissimo tempo. (Possiamo anche decidere di mantenere questa nostra implementazione utilizzabile solo per i test)

Creiamo la classe @SingletonOrderRepository@ nel nostro _classpath di test_ e popoliamola con il codice mostrato in basso:

div(filename). src/test/java/org/arquillian/example/SingletonOrderRepository.java

bc(prettify).. package org.arquillian.example;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.annotation.PostConstruct;
import javax.ejb.Lock;
import javax.ejb.LockType;
import javax.ejb.Singleton;

@Singleton
@Lock(LockType.READ)
public class SingletonOrderRepository implements OrderRepository {
    private List<List<String>> orders;
    
    @Override
    @Lock(LockType.WRITE)
    public void addOrder(List<String> order) {
        orders.add(order);
    }
    
    @Override
    public List<List<String>> getOrders() {
        return Collections.unmodifiableList(orders);
    }
    
    @Override
    public int getOrderCount() {
        return orders.size();
    }
    
    @PostConstruct
    void initialize() {
        orders = new ArrayList<List<String>>();
    }
}

p. L'extra fornito perr quest'implementazione è che possiamo giocare con le nuove funzionalità degli EJB 3.1 (la Singleton) dentro la sandbox di Arquillian. Ci piace dire che Arquillian è un ottimo ambiente per studiare e imparare oltre che per testare.

Ora siamo pronti per scrivere il test Arquillian.

h3. Scrivere un Test

Stiamo per scrivere un test che simula l'aggiunta degli oggetti in un'istanza di @Basket@ sotto forma di ordini e che verifica che l'ordine sia processato e registrato nell'istanza dell'@OrderR
epository@.

p(info). %Naturalmente, testeremo soltanto l'implementazione in-memory. Se volete vedere come testare un'applicazione che usa il database potete consultare la guida "Testare la Persistenza Java":/guides/testing_java_persistence guide. Potrete poi tornare in questa guida e modificarne l'implementazione.%

Creiamo la classe @BasketTest@ e annotiamola con @@RunWith(Arquillian.class)@ per trasformarla in un test Arquillian:

div(filename). src/test/java/org/arquillian/example/BasketTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.junit.Arquillian;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class BasketTest {
}

p. Definiamo poi un archivio di test che include il carrello, l'interfaccia order repository e l'implementazione singleton. Abbiamo anche bisogno di un file beans.xml vuoto per attivare la parte CDI (L'EJB è attivato automaticamente). Da notare come abbiamo il controllo completo del classpath definendo esplicitamente cosa mettere nell'archivio.

div(filename). src/test/java/org/arquillian/example/BasketTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class BasketTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class, "test.jar")
            .addClasses(Basket.class, OrderRepository.class, SingletonOrderRepository.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }
}

p. Ora rimane da fare fare l'injection del carrello e dell'order repository nel test ed eseguirlo. Eseguiremo l'injection dell'interfaccia EJB, non dell'implementazione. Il container EJB automaticamente troverà l'implementazione dell'interfaccia da usare.

Per default in JUnit, i metodi @@Test@ sono eseguiti in un ordine non definito. L'integrazione di JUnit su Arquillian prevede un'annotazione @@InSequence@ che può essere usata per definire l'ordine di esecuzione. Noi useremo il @@InSequence@ in questo test per eseguire prima l'inserimento di due ordini nel primo metodo di test, e poi assicurarsi che il repository conterrà questi due oggetti nel secondo metodo di test.

div(filename). src/test/java/org/arquillian/example/BasketTest.java

bc(prettify).. package org.arquillian.example;

import javax.ejb.EJB;
import javax.inject.Inject;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.arquillian.junit.InSequence;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class BasketTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class, "test.jar")
            .addClasses(Basket.class, OrderRepository.class, SingletonOrderRepository.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }
    
    @Inject
    Basket basket;
    
    @EJB
    OrderRepository repo;
    
    @Test
    @InSequence(1)
    public void place_order_should_add_order() {
        basket.addItem("sunglasses");
        basket.addItem("suit");
        basket.placeOrder();
        Assert.assertEquals(1, repo.getOrderCount());
        Assert.assertEquals(0, basket.getItemCount());
        
        basket.addItem("raygun");
        basket.addItem("spaceship");
        basket.placeOrder();
        Assert.assertEquals(2, repo.getOrderCount());
        Assert.assertEquals(0, basket.getItemCount());
    }
    
    @Test
    @InSequence(2)
    public void order_should_be_persistent() {
        Assert.assertEquals(2, repo.getOrderCount());
    }
}

p. Il test è stato scritto. Ora dobbiamo configurarlo e lanciarlo.

h3. Aggiungere i Container remoti

Il test che abbiamo scritto usa sia CDI che EJB. Questa combinazione è utilizzabile in un ambiente integrato (Come per esempio Weld Embedded o OpenEJB Embedded). E' comunque più semplice usare direttamente un container EE compliant. In più, ci permette di eseguire test più realistici. Quindi al momento mettiamo da parte i container integrati.

Nella guida precedente, abbiamo usato entrambi i container di tipo embedded e managed. In entrambi i casi, Arquillian deve lanciare il container quando viene eseguita la suite di test e deve fermarlo quando i test sono terminati. Cosa fare se abbiamo già un container attivo (o vogliamo lanciarne uno a scopo di test)? Quello è sicuramente il modo più rapido per lanciare i test. Anche se il container è molto veloce a partire, un container già avviato è sicuramente più rapido.

I container remoti forniscono un ambiente di sviluppo ideale per i test di integrazione. Permettono anche di eseguire il debug in modo molto semplice, come vedremo più avanti. Dal momento che non ci sono referenze al container direttamente nel test, è possibile usare un container remoto durante gli sviluppi. In questo caso configureremo il container managed che è tralaltro la soluzione migliore negli ambienti di continous integration.

p(warning). %Il termine _remoto_ si riferisce ad un processo separato, non necessariamente a una macchina separata, sebbene siano supportati entrambi gli scenari.%

Un container remoto è un processo standalone in cui Arquillian esegue il deploy tramite delle API client. Perciò abbiamo bisogno delle seguenti librerie:

* API dei modelli (che possono semplicemnete essere aggiunti al pacchetto se il container non le fornisce già)
* Il remote container adapter di Arquillian
* Le API client per il deploy per comunicare con il processo del container

Nel nostro file pom.xml, aggiungiamo due nuovi profili all'interno dell'elemento @<profiles>@. Il primo profilo usa il container remoto di Boss AS 7.1:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-jbossas-remote</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.as</groupId>
            <artifactId>jboss-as-arquillian-container-remote</artifactId>
            <version>7.1.1.Final</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.arquillian.protocol</groupId>
            <artifactId>arquillian-protocol-servlet</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p(info). %Di default, JBoss AS 7 usa il protocollo JMX per ricevere gli archivi di test. Noi siamo andati oltre e abbiamo aggiunto una dipendenza al protocollo Servlet nel profilo @arquillian-jbossas-managed@ che potrà essere usato in futuro. Per istruzioni su come passare da JMX a Servlet rimandiamo a "queste FAQ":https://community.jboss.org/wiki/WhyDoIGetNoActiveContextsForScopeTypeWhenTestingOnJBossAS7.%

p. Il secondo profilo usa il container remoto di GlassFish 3.1.2:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-glassfish-remote</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.weld</groupId>
            <artifactId>weld-api</artifactId>
            <version>1.1.Final</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.arquillian.container</groupId>
            <artifactId>arquillian-glassfish-remote-3.1</artifactId>
            <version>1.0.0.CR3</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p(info). %L'adapter remoto di GlassFish usa Jersey per comunicre con il container tramite JAX-RS (REST), che è integrato come dipendenza transitiva. Sono richieste le API Weld per gestire le eccezioni dei test all'interno del container.%

Una volta aggiunti i profili nel pom.xml, clicchiamo con il tasto destro sul progetto in Eclipse e seleziniamo Maven > Update Project Configuration. Se il progetto mostra errori di compilazione, dobbiamo attivare uno dei due profili.

Ricordiamoci che ci sono due modi per attivare un profilo Maven in Eclipse (presupponendo che stiamo usando il plugin "Maven Integration for Eclipse":http://www.eclipse.org/m2e):

# Configurazione manuale (approccio standard)
# selettore del profilo Maven (JBoss Tools)

Riferitevi alla "Guida Introduttiva"d":/guides/getting_started#test_across_containe per istruzioni su come attivare un profilo. Una volta che il profilo è attivato, il progetto dovrebbe compilare con successo.

Gli adapter per il container remoto si aspettano che il container sia avviato. Perciò, diamo un'occhiata alla configurazione dei container in modo che possiamo lanciarli comodamente dal nostro IDE prima di far partire i test.

h3. Configurazione dei Server

Il modo più semplice per gestire i container remoti è di configurarli all'interno dell'IDE. Se vi sentite più a vostro agio con la riga di comando, potete saltare questo passaggio e lanciare il server utilizzando il rispettivo script di lancio.

Mostriamo ora come aggiungere i controlli del server (container) in Eclipse. Il processo è simile per gli altri IDE. Con Eclipse, abbiamo bisogno sia di "JBoss Tools":http://jboss.org/tools che di "GlassFish Java EE Application Server Plugin":http://marketplace.eclipse.org/content/glassfish-java-ee-application-server-plugin-eclipse/metrics, entrambi disponibili nel MarketPlace di Eclipse.

Da Eclipse, selezioniamo Window > Show View > Servers dalla barra principale. Una volta aperta la finestra, tasto destro e selezioniamo New > Server. Creiamo un controllore del server per JBoss AS 7.1:

!/images/guides/arquillian_tutorial_2_new_jbossas_server.png!

e un'altro per GlassFish 3.1.2:

!/images/guides/arquillian_tutorial_2_new_glassfish_server.png!

p(info). %Il wizard per JBoss AS richiede di selezionare un'installazione già esistente. Il wizard di Glassfish 3.1.2 fornisce un'opzione automatica per il download e l'estrazione della distribuzione.%

Una volta completato il wizard per il container, dovrebbe comparire questo nella finestra dei server:

!/images/guides/arquillian_tutorial_2_servers_view.png!

Per lanciare un server, selezioniamo il blocco (mostrato graficamente) e clicchiamo sul tasto di play nella toolbar.

p(info). %Arquillian presuppone che i container vengano lanciati sulle porte di default. Se avete cambiato le porte, si può configurare il file arquillian.xml per specificare le porte usate per ogni container. Consultate la "reference guide":https://docs.jboss.org/author/display/ARQ/Container+adapters per maggiori dettagli.%

Ora che i container sono pronti e in attesa, è tempo di lanciare il test.

h3. Lanciare il Test Arquillian

To run the Arquillian test, you need to perform three steps:

# Start the remote container
# Activate the Maven profile that adds the cooresponding container adapter to the classpath
# Run the test

Let's start with JBoss AS.

h4. Run the Test on JBoss AS

To run the test on JBoss AS, begin by starting the JBoss AS container. Open the Servers view, select JBoss AS 7.1, then click the green play button. Wait for it to start (it shouldn't take long).

Once that's up and running, activate the @arquillian-jbossas-remote@ Maven profile using either the Maven properties tab or the JBoss Tools Maven profile selector. The profile editor below shows the correct selection.

!/images/guides/arquillian_tutorial_2_jbossas_profile_selection.png!

Finally, right click on the @BasketTest@ class and select Run As > JUnit Test. You should see a flurry of activity in the Console view and then...a *(greenbar)green bar* in the JUnit view!

You can also run the test on the commandline using Maven:

bc(command). $ mvn test -Parquillian-jbossas-remote -Dtest=BasketTest

You should see the following lines printed to the console:

bc(output). -------------------------------------------------------
T E S T S
-------------------------------------------------------
Running org.arquillian.example.BasketTest
...
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.844 sec

*Congratulations!* You've earned your first *(greenbar)green bar* with Arquillian using a remote container.

p(info). %You can also inject the @OrderRepository@ EJB using @@Inject@ rather than @@EJB@. Give it a try!%

If you want to verify that the singleton is actually doing its job, go ahead and remove the @@Singleton@ annotation from the @SingletonOrderRepository@ class and replace it with @@Stateful@. You should see an assertion error when you run the test. Revert the change and the bar will go back to green.

We are done with JBoss AS for the moment, so use the Servers view to stop the server. Now let's test the exact same test in GlassFish 3.1.2.

h4. Run the Test on GlassFish

To run the test on the standalone GlassFish server, begin by starting the server. Open the Servers view, select GlassFish 3.1.2, then click the green play button. Wait for it to start.

Once that's up and running, activate the @arquillian-glassfish-remote@ Maven profile using either the Maven properties tab or the JBoss Tools Maven profile selector. Remember to deactivate the @arquillian-jbossas-remote@ profile. The profile editor below shows the correct selection.

!/images/guides/arquillian_tutorial_2_glassfish_profile_selection.png!

Finally, right click on the @BasketTest@ class and select Run As > JUnit Test. You should see a flurry of activity in the Console view and then...a *(greenbar)green bar* in the JUnit view!

You can also run the test on the commandline using Maven:

bc(command). $ mvn test -Parquillian-glassfish-remote -Dtest=BasketTest

You should see the following lines printed to the console:

bc(output). -------------------------------------------------------
T E S T S
-------------------------------------------------------
Running org.arquillian.example.BasketTest
...
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.549 sec

*Congratulations!* You've earned another *(greenbar)green bar*.

You should still be able to run the test on Embedded GlassFish using the profile you setup in the previous guide. Give it a try. You should also be able to debug the test easily.

Of course, debugging the test in an embedded container is easy since it runs in the same process as the test launcher. But what about a remote container?

h3. Debug the Arquillian Test

Debugging a test in a remote container? That seems hard. Surprise! It's not at all. You only have to modifiy one of the step above and add one additional step:

# *Debug the remote container*
# Activate the Maven profile that adds the corresponding container adapter to the classpath
# *Set a breakpoint*
# Run the test

In the Servers view, you should notice that there is a bug icon right next to the green play button. Click this button to start one of the servers in debug mode. Eclipse automatically connects its debugger to the container.

Set a breakpoint in the @addOrder()@ method on the @SingletonOrderRepository@ bean. Now, run the test again by right clicking and selecting Run As > JUnit Test.

p(warning). %You don't need to use Debug As > JUnit Test. The test code is running inside the container, which is already being debugged.%

The test should halt at the breakpoint. If you are using JBoss AS, you can open the administration console and verify that the test application is currently deployed to the server.

If you browse the stack trace in the Eclipse Debug view, you'll notice that the server is being controlled over a remote protocol (either JMX or Servlet) and that JUnit has been launched again from inside the container.

!/images/guides/arquillian_tutorial_2_debug_remote_test.png!

You are now poking around the server from the comfort of your IDE.

p(warning). %If you see the message "Source not found" in the editor view when the debugger stops at the breakpoint, you need to add the project to the debug configuration. Click "Edit Source Lookup Path...", then click "Add...", select Java Project, check the box next to your project then click "OK". Voila! Source code.%

h4. Stepping into External Libraries

If you plan to step into a class in an external library (code outside of your application), you need to link the library to its source code.

p(info). %This configuration is not necessary if you are using a Maven project and the sources for the library are available in the Maven repository. When you hit a breakpoint in a library not yet available locally, give it some time to download and the source code will eventually be revealed. If not, the source is probably not in the repository and you need to read on.%

Here are the steps you need to follow to link a library to its source in the debug configuration:

# Select the @Run > Debug Configurations...@ menu from the main menubar
# Select the name of the test class in the JUnit (or TestNG) category
# Select the Source tab
# Click the Add... button on the right
# If the source code is in another project:
## Select Java Project
## Check the project that contains the class you want to debug
## Click OK on the Project Selection window
# If the source code is in a library:
## Select External Archive
## Navigate to the archive that contains the source code (which you have to download, of course)
# Click Close on the Debug Configurations window

You'll have to complete those steps for any test class you are debugging, though you only have to do it once (the debug configuration sticks around indefinitely).

h3. Debug a Managed Server

Is it possible to debug when using a managed container? You bet! We just need a little extra configuration.

Since Arquillian handles starting and stopping the container, we need to instruct Arquillian to start the container in debug mode. That's a JVM hint that Arquillian needs to pass to the server, which we'll supply using a container configuration property.

Before we get to that, we need to think about how we are going to connect the debugger. Unless you're super speedy with the mouse, you're going to have a hard time connecting the debugger before Arquillian starts running the tests. Fortunately, we can tell the JVM to wait for the connector to debug before executing the application, in this case JBoss AS. That gives us time to hit the debug button in the IDE to connect to the process.

Here's the configuration you'll need to add to the Arquillian configuration descriptor, arquillian.xml, to get Arquillian to start the server in debug mode: (No whitespace is allowed immediately after @<property>@ start tag)

div(filename). src/test/resources/arquillian.xml

bc(prettify).. <arquillian xmlns="http://jboss.org/schema/arquillian"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://jboss.org/schema/arquillian
        http://jboss.org/schema/arquillian/arquillian_1_0.xsd">
    <container qualifier="jbossas-managed" default="true">
        <configuration>
            <property name="jbossHome">target/jboss-as-7.1.1.Final</property>
            <property name="javaVmArguments">-Xmx512m -XX:MaxPermSize=128m
                -Xrunjdwp:transport=dt_socket,address=8787,server=y,suspend=y
            </property>
        </configuration>
    </container>
</arquillian>

p. Notice the @suspend=y@ flag. That tells the process to wait for the debugger to connect. We've set the debug port to 8787, which is the port you'll supply to the debugger configuration. We'll get to that in a minute. First, let's get the test started.

# Activate the Maven profile for @arquillian-jbossas-managed@ (refer to the "Getting Started":/guides/getting_started guide)
# Run the test

In the Console view, you should notice that Arquillian has started the JBoss AS instance and it's waiting on the debugger to connect:

bc(output). Listening for transport dt_socket at address: 8787

All we have to do now is connect a debugger. Here's how you configure and launch the debugger in Eclipse:

# Select @Run > Debug Configurations...@ from the main menu
# Right click on Remote Java Application and select New
# In the Name field, enter "Debug JBoss AS"
# In the Port field, enter "8787"
# Click the Debug button

Here's the debug configuration screen showing the debug profile we've created:

!/images/guides/arquillian_tutorial_2_eclipse_debug_configuration.png!

When you click the Debug button, JBoss AS should resume, then stop again when it hits the breakpoint in your test. Voila! You're debugging a managed container!

h3. Export the Deployment

Sometimes you need to get a little more insight about what Arquillian is deploying to the server. Fortunately, Arquillian provides a way to export the archive just before deploying it. Assign a relative or absolute directory to the @deploymentExportPath@ property of the @<engine>@ element in arquillian.xml and Arquillian will export the archive to that location for any Arquillian test you run.

div(filename). src/test/resources/arquillian.xml

bc(prettify).. <arquillian xmlns="http://jboss.org/schema/arquillian"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://jboss.org/schema/arquillian
        http://jboss.org/schema/arquillian/arquillian_1_0.xsd">
    <engine>
        <property name="deploymentExportPath">target/deployments</property>
    </engine>
</arquillian>

p. To enable the export for just a single test, use the VM argument @arquillian.deploymentExportPath@. For example: @-Darquillian.deploymentExportPath=target/deployments/@.

Now run a test and check the target/deployments folder. You should see a file with the extension .jar, .war or .ear. (Arquillian may have packaged the archive defined in the test inside another archive in order to add some magic). You can inspect the contents of this file using an archive manager. Hopefully the contents of the archive will give you the necessary insight to track down class not found or resource missing exceptions.

At this point, you've learned how to run and debug your tests in embedded, remote and managed containers. There's no holding you back now. Keep on writing _real tests_ and make Ike proud!
