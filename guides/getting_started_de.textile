---
layout: guide
title: Erste Schritte
authors: ['Markus Eisele']
tags: [cdi, weld, maven, forge, eclipse]
guide_summary: Lerne, wie Du die Arquillian Testsuite zu Deinem Projekt hinzufügst und schreibe die ersten Arquillian Tests.
guide_group: 1
guide_order: 10
TODO: ["Explain how to debug w/ JBoss AS managed"]
---
[forge_home]http://jboss.org/forge
[forge_download]https://repository.jboss.org/nexus/service/local/artifact/maven/redirect?r=releases&g=org.jboss.forge&a=forge-distribution&v=1.0.0.Beta3&e=zip
[maven_home]http://maven.apache.org
[maven_download]http://maven.apache.org/download.html
[maven_search]http://search.maven.org
[jdk_download]http://www.oracle.com/technetwork/java/javase/downloads/jdk-6u29-download-513648.html
[as7_download]http://jboss.org/jbossas/downloads
[tools_home]http://jboss.org/tools
[shrinkwrap_home]http://jboss.org/shrinkwrap
[m2e_home]http://eclipse.org/m2e

Dieser Guide stellt Arquillian vor. Nach dem Lesen dieses Guides kannst Du:

* Arquillian zu einem Maven basierten Projekt hinzufügen
* einen Arquillian Testcase schreiben der das Verhalten eines CDI (Context and Dependency Injection) Beans überprüft.
* den Arquilian Testcase in verschiedenen Containern ausführen.

Du wirst all dies lernen indem du Arquillian als Testsuite zu einem Java EE basierten Maven Projekt hinzufügst. Wir haben diesen Guide so entworfen,
dass du ihn schnell durcharbeiten kannst du sofort starten kannst!

h3. Annahmen

Der einfachste Weg, mit Arquillian anzufangen ist, wenn man es in ein Projekt integriert welches bereits Abhängigkeitsmanagement (Dependency Management) unterstützt. Das am weitesten Verbreitete Werkzeug dieser Kategorie heutzutage ist "Apache Maven":maven_home. Dieser Guide führt Dich zu Deiner ersten *(greenbar)green bar* (grüner Testbalken) mithilfe eines Beispiel Maven Projekts.

p(info). %Arquillian basiert nicht auf Maven oder irgendeinem anderen Build-Tool. Es funktioniert genauso gut --wenn nicht besser-- wenn es in einem Projekt verwendet wird, welches einen Ant oder Gradle build einsetzt. Idealerweise sollte das Build-Werkzeug allerdings dependency management anbieten, da es die Integration der Arquillian Bibliothken deutlich vereinfacht, weil diese bereits im "Maven Central repository":maven_search vorliegen.% 

Dieser Guide setzt voraus, dass bei Dir Maven installiert ist. Entweder als Kommando-Zeilen Werkzeug oder in Deiner IDE (Integrated Development Environment). Wenn nicht, bitte "installiere Maven jetzt":maven_download. Du wirst auch ein "JDK(Java Development Kit) 1.6":jdk_download oder neuer auf Deinem Rechner benötigen.

h3. Erstelle ein neues Projekt

Es gibt zwei von uns empfohlene Wege ein neues Maven Projekt zu erstellen:

# "Erstelle ein Projekt von einem Maven archetype":#generate_project_from_archetype
# "Erstelle und passe ein Projekt mit JBoss Forge an":#create_project_using_forge

p(info). %Wenn Du bereits ein Maven basiertes Projekt hast, kannst Du diese Sektion als referenz verwenden um sicherzustellen, dass Du die richtigen Abhängigkeiten im Projekt hast bevor Du weitermachst.%

Mit Abstand stellt "JBoss Forge":forge_home den einfachereren Weg dar. Dieser Guide bietet beide Alternativen an, für den Fall dass du noch nicht bereit bist JBoss Forge einzusetzen. Wähle eine der obigen Optionen um zur jeweiligen Anleitung zu springen.

h4(#generate_project_from_archetype). Erstelle ein Projekt von einem Maven Archetype

Zuerst erstelle ein Maven basiertes Java projekt mithilfe der Kommand-Zeile unten. Kopiere den Text nach dem @$@ und füge ihn in deine Kommando-Zeilen-Fenster ein. 

bc(command).. $ mvn archetype:generate -DarchetypeGroupId=net.avh4.mvn.archetype \
-DarchetypeArtifactId=java-1.6-archetype

p. Füge, wenn Du dazu aufgefordert wirst die in der folgen Liste stehenden Werte ein und bestätige sie mit @<ENTER>@.

bc(output). Define value for property 'groupId': : org.arquillian.example <ENTER>
Define value for property 'artifactId': : arquillian-tutorial <ENTER>
Define value for property 'version': : <ENTER>
Define value for property 'package': : <ENTER>
Confirm properties configuration:
groupId: org.arquillian.example
artifactId: arquillian-tutorial
version: 1.0-SNAPSHOT
package: org.arquillian.example
Y: : <ENTER>

p. Dieses Kommando erzeugt ein Maven basiertes Java Projekt innerhalb eines Verzeichnisses mit dem Namen @arquillian-tutorial@ unterhalb des aktuellen Verzeichnisses. Die Dateistruktur des Projekt ist wie folgt:

(Dateibaum)* src/
** main/
*** java/ - Hier kommen alle Java Source Dateien hin (in Java Packages)
*** resources/ - Hier kommen alle Konfigurationsdateien der Anwendung hin. 
** test/
*** java/ - Hier kommen alle Test Java Source Dateien hin (in Java Packages)
*** resources/ - Hier kommen alle Konfigurationsdateien der für die Tests hin, (beispielsweise: arquillian.xml)
* pom.xml - Die Maven Build Datei, welche Maven sagt, wie das Projekt zu bauen ist.

p(info). %Das erzeugte Projekt ist mit Java 6 und JUnit 4.8 vorkonfiguriert. Dies sind die im Minimum benötigten Versionen von Java und JUnit um Arquillian zu nutzen.%

Der Generator hat auch ein Java Package mit dem Namen @org.arquillian.example@ unterhalb der beiden @java@ Verzeichnisse erstellt. Dorthin solltest Du auch Deine Java Sourcen packen und nicht direkt in das Root der @java@ Verzeichnisse.

p(warning). %Arquillian unterstützt auch TestNG 5. Dennoch verwendet dieser Guide JUnit als Beispiel.%

Öffnet als nächstes das @pom.xml@ in Deiner IDE oder einem Editor. Du solltest eine XML Datei mit den basis Projekt Informationen, einer @<build>@ und einer @<dependencies>@ section sehen. *Du kannst alle <dependency> Elemente unterhalb der JUnit Abhängigkeit entfernen. Sie werden nicht benötigt.*

Wenn Du fertig bist, sollte das Ergebnis ungefähr so aussehen (Abgekürzt zur besseren Lesbarkeit):

div(filename). pom.xml

bc(prettify).. <project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.arquillian.example</groupId>
    <artifactId>arquillian-tutorial</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>arquillian-tutorial</name>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>

p. Wir werden Java EE 6 Komponenten schreiben. Daher benötigst Du ausserdem die Java EE 6 API als abhängige Bibliothek im Classpath um diese kompilieren zu können.

Öffne erneut die @pom.xml@ Datei und füge das folgende XML Fragment direkt innerhalb der umschließenden @<dependencies>@ Elemente ein. Das sollte dann so aussehen, wenn Du fertig bist:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>org.jboss.spec</groupId>
        <artifactId>jboss-javaee-6.0</artifactId>
        <version>1.0.0.Final</version>
        <type>pom</type>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.8.1</version>
        <scope>test</scope>
    </dependency>
</dependencies>
<!-- clip -->

p(important). %Wir empfehlen dringen, dass Du die Java EE API Artifakte mit der groupId @javax:javaee-api@ *nicht verwendest*. Dieses Abhängigkeit enthält Klassen mit verkürzten Methoden, welche dazu führen können, dass bei der Ausführung der Anwendung oder der Tests komische Absent Code errors erscheinen sobald sich diese Klassen im Classpath befinden. "Mehr dazu in dieser FaQ":http://community.jboss.org/wiki/WhatsTheCauseOfThisExceptionJavalangClassFormatErrorAbsentCode .%

p. Die Grundlagen für Dein Projekt sind jetzt fertig! Überspringe den nächsten Abschnitt und gehe direkt zu "Projekt in Eclipse öffnen":#open_project_in_eclipse damit wir endlich Code schreiben können!

h4(#create_project_using_forge). Erstelle und passe ein Projekt mit JBoss Forge an

"JBoss Forge":forge_home ist ein Kommando-Zeilen Werkzeug zum Rapid-Application Development in einer auf Standards basierenden Umgebung. Gerne auch als "Maven Archetypes on steroids" bezeiochnet.

Forge ist schnell installiert und dieser Guide führt Dich durch die Grundlagen. Folge einfach diesen einfachen Schritten um es zu installieren:

# "Download Forge":forge_download und packe Forge in ein beliebiges Verzeichnis auf Deiner Festplatte aus. Diese nennen wir @$FORGE_HOME@
Wir gehen davon aus, dass Du die Distribution in ein Verzeichnis mit dem namen @forge@ in Deinem Home Verzeichnis ausgepackt hast.

# Füge @$FORGE_HOME/bin@ zu Deinem Pfad hinzu (Windows, Linux or Mac OSX)

Auf Unix basierenden Systemen bedeutet dies, dass Du $HOME/.bashrc or $HOME/.profile editieren musst. Eine entsprechende Ergänzung sieht dann beispielsweise so aus:

bc(command). $ export FORGE_HOME=$HOME/forge/
$ export PATH=$PATH:$FORGE_HOME/bin

p(info). %Unter Windows kann dies über die Systemeigenschaften eingestellt werden. Dorthin gelangst Du mit einem Rechts-Klick auf die "Systemsteuerung", dann Klick auf "System Eigenschaften", dort der Tabreiter "Erweitert". Ein Klick auf "Umgebungsvariablen" ermöglicht das Hinzufügen der beiden Einträge. Es wird empfohlen die Einträge als Nutzer Variablen vorzunehmen. System Variablen ist nur sinnvoll, wenn Forge in einem Verzeichnis installiert ist, welches von allen Systembenutzern gelesen werden kann.%

Nachdem Forge installiert (bzw. entpackt) wurde öffne die Kommandozeile und führe das folgende @forge@ Kommando aus:

bc(command).. $ forge
   _____                    
  |  ___|__  _ __ __ _  ___ 
  | |_ / _ \| `__/ _` |/ _ \  \\
  |  _| (_) | | | (_| |  __/  //
  |_|  \___/|_|  \__, |\___| 
                   |___/      
 
[no project] ~ $

p. Das war es schon! Forge läuft und es wird Zeit, dass Projekt zu erstellen.

Tippe das folgende Kommando innerhalb der Forge shell. Es erzeugt ein leeres Projekt in etwa der Art wie es der Maven Archetype auch getan hat:

bc(command). $ new-project --named arquillian-tutorial --topLevelPackage org.arquillian.example

p. Dieses Kommando erzeugt ein Maven basiertes Java project innerhalb eines @arquillian-tutorial@ genannten Verzeichnisses direkt unterhalb des aktuellen Verzeichnisses.

The file structure of the project Forge generates is shown below:
Die Dateistruktur ist dabei wie folgt erzeugt worden:

(Dateibaum)* src/
** main/
*** java/ - Hier kommen alle Java Source Dateien hin (in Java Packages)
*** resources/ - Hier kommen alle Konfigurationsdateien der Anwendung hin. 
**** META-INF/
***** forge.xml - Eine leere Forge Settings Datei
** test/
*** java/ - Hier kommen alle Java Test Source Dateien hin (in Java Packages)
*** resources/ - Hier kommen alle Konfigurationsdateien der für die Tests hin, (beispielsweise: arquillian.xml)
* pom.xml - Die Maven Build Datei, welche Maven sagt, wie das Projekt zu bauen ist.

Forge wechselt automatisch in das erstelle Projektverzeichnis.

bc(command). [arquillian-tutorial] arquillian-tutorial $ 

Standardmäßig erstellt Forge Projekte, welche Java 1.6 verwenden. Das passt sehr gut, da dies auch die Minimalanforderung von Arquillian an die Projekte ist.

Nun müssen die Java EE 6 APIs hinzugefügt werden. Das wird mit dem @project add-dependency@ Kommando gemacht:

bc(command). $ project add-dependency org.jboss.spec:jboss-javaee-6.0:1.0.0.Final:pom:provided

Dann fehlt noch JUnit 4.8 für die Tests, als weitere Minimalanforderung von Arquillian.

bc(command). $ project add-dependency junit:junit:4.8.1:test

Im Ergebnis sieht die von Forge erzeugte pom.xml dann so aus:

div(filename). pom.xml

bc(prettify).. <?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xsi:schemaLocation="
        http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.arquillian.example</groupId>
    <artifactId>arquillian-tutorial</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>provided</type>
            <scope>pom</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <repositories>
      <repository>
          <id>JBOSS_NEXUS</id>
          <url>http://repository.jboss.org/nexus/content/groups/public</url>
      </repository>
    </repositories>
    <build>
        <finalName>arquillian-tutorial</finalName>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

p(info). %Arquillian kann über das Maven Central Repository bezogen werden. Daher ist der Verweis auf das JBoss Public Repository in der pom.xml überflüssig und kann entfernt werden. Behalte aber im Hinterkopf, dass es durchaus abhängige Bibliotheken von JBoss gibt, welche nicht über Maven Central bezogen werden können.%

p(warning). %Wenn Du zu den Anhängern gehörst, welche das Hinzufügen von Repositories in Projekt pom.xml für ein Anit-Pattern halten, dann lies "diese Anweisungen":http://community.jboss.org/wiki/MavenGettingStarted-Users um die Repositories global in der Maven settings.xml Datei einzustellen.%

p. Die Grundlagen für Dein Projekt sind jetzt fertig! Öffne das Projekt in Eclipse, damit wir endlich Code schreiben können!

h3. Projekt in Eclipse öffnen

Beim Entwickeln eines Java Projektes wirst Du vermutlich eine IDE, beispielsweise Eclipse, verwenden. Daher wurde Arquillian auch IDE-freundlich konzipiert. Das bedeutet, dass Arquillian Tests aus der IDE ohne besondere Änderungen ausführbar sind. Darum starten wir auch gleich mit der IDE:

Starte Eclipse. Da dies ein Maven basiertes Projekt ist, benötigst Du die "Maven Integration for Eclipse":m2e_home auch m2e Plugin genannt um das Projekt zu öffnen. Hast Du diese nicht bereits installiert, kannst Du auch einfach die "JBoss Tools":tools_home installieren. Sie enthalten die Mavene Integration bereits. Die folgenden Schritte beschreiben die Installation direkt über den Clipse Marketplace (eine Art Eclipse AppStore).

# Wähle das Menü @Hilfe > Eclipse Marketplace...@ vom Hauptmenü
# Tippe "jboss tools" in in das Eingabefeld (ohne Anführungszeichen) und drücke <ENTER>
# Klicke auf den "Installieren" Knopf neben dem Ergebnis "JBoss Tools (Indigo)"
# Beende den Install Wizard und starte Eclipse neu wenn Du dazu aufgefordert wirst.

Die JBoss Tools bieten ein umfangreiches Set and Werkzeugen zur Entwicklung von Java EE Anwendungen, inklusive CDI Unterstützung. Und es ist kein schwergewichtiges Plugin.

Aber auch wenn Du nur die Maven Integration ohne all die JBoss Tools Extras möchtest, folge diesen einfachen Schritten:

# Select @Help > Eclipse Marketplace...@ from the main menu
# Tippe "maven" in in das Eingabefeld (ohne Anführungszeichen) und drücke <ENTER>
# Klicke auf den "Installieren" Knopf neben dem Ergebnis "Maven Integration for Eclipse"
# Beende den Install Wizard und starte Eclipse neu wenn Du dazu aufgefordert wirst.
# Wiederhole die Schritte für die "Maven Integration für Eclipse WTP"

Ist das Maven Plugin installiert, kann man mit einfachen Schritten das Projekt direkt öffnen:

# Wähle @Datei > Import...@ vom Hauptmenü
# Tippe "existing maven" in in das Eingabefeld
# Wähle die Option "Existing Maven Projects", dann klicke auf den Weiter Knopf
# Klicke den "Durchsuchen ...." Knopf
# Navigiere zum Projekt Verzeichnis in Deinem Dateisystem, dann Klicke den OK Knopf.
# Klicke auf "Fertig" um das Projekt zu öffnen

Eclipse erkennt dann das Maven projekt und öffnet es im Projekt Navigator View. Wenn Du das Projekt ausklappst, sollte es folgendermaßen aussehen:

!/images/guides/arquillian_tutorial_eclipse_project.png!

Jetzt kann es aber wirklich losgehen!

h3. Eine Komponente erstellen

Um einen Arquillian Test schreiben zu können, benötigen wir erst einmal eine Komponente welche es zu testen gibt. Wir fangen an mit einer einfachen Komponente, damit Du lernen kannst, wie ein einfacher Arquillian Test ausgeführt wird. In den nächsten Schritten geht es zu deutlich komplexeren Szenarien.

Erstelle mithilfe Deiner IDE eine neue Java Klasse mit dem Namen @Greeter@ im @org.arquillian.example@ Package. Ersetze den Inhalt mit dem folgenden Code:

div(filename). src/main/java/org/arquillian/example/Greeter.java

bc(prettify).. package org.arquillian.example;

import java.io.PrintStream;

/**
 * A component for creating personal greetings.
 */
public class Greeter {
    public void greet(PrintStream to, String name) {
        to.println(createGreeting(name));
    }

    public String createGreeting(String name) {
        return "Hello, " + name + "!";
    }
}


p. Im Test wollen wir sicherstellen, dass diese Klasse sich richtig verhält, wenn sie als CDI(Contexts and Dependency Injection) bean aufgerufen wird. Natürlich könnten wir jetzt auch einen einfachen Unit-Test schreiben, aber lass uns einfach annehmen, dass diese bean weitere Enterprise Services wie beispielsweise Dependency Injection und Messaging nutzt und in einem Container ausgeführt werden muss. (Und außerdem hat es so Raum zu wachsen ~;)) 

Um diese Klasse als CDI Bean zu benutzen injizieren wir sie in den Test mithilfe der @@Inject@ Annotation. Das schreit gradezu nach einem Arquillian Test! Nun wird es also Zeit, die Arquillian API zum Projekt hinzu zu fügen!

h3. Arquillian APIs hinzufügen

Öffne die @pom.xml@ ein weiteres mal im Editor. (Erinnerung: Sie liegt im root Verzeichnis Deines Projektes). Jetzt muss Maven wissen, welche Version der Abhängigkeiten es verwenden soll. Dazu wird das folgende XML Fragment direkt oberhalb des @<build>@ Elements eingefügt um den sogenannten BOM(Bill of Materials) bzw. die Versions-Matrix für alle transitiven Abhängigkeiten von Arquillian zu importieren.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian</groupId>
            <artifactId>arquillian-bom</artifactId>
            <version>1.0.0.Final</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
    </dependencies>
</dependencyManagement>
<!-- clip -->

p. Nun muss die Arquillian JUnit Integration als Abhängigkeit ergänzt werden. Dazu gehört dieses XML Fragment unter das letzte geschlossene @<dependency>@ element:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.junit</groupId>
    <artifactId>arquillian-junit-container</artifactId>
    <scope>test</scope>
</dependency>
<!-- clip -->

p. Die Arquillian JUnit Integration fügt auch die Arquillian und die ShrinkWrap APIs zum Test Classpath hinzu. Alle diese Bibliothken werden benötigt um einen Arquillian Test schreiben und compilieren zu können.

p(info). %To use TestNG instead of JUnit, substitute the Arquillian JUnit integration with the Arquillian TestNG integration.%

p. If you're having trouble with the pom.xml up to this point, you can download the file from "this gist":https://gist.github.com/1263892.

*You're all set to write your first Arquillian test!*

h3. Write an Arquillian Test

An Arquillian test looks just like a unit test, just with some extra flair. Let's return to the IDE.

p(warning). %If you get the message "Project configuration is out of date with pom.xml" then right click and select Project > Maven > Update Project Configuration to resync the project.%

Begin by creating a new JUnit test case in src/test/java under the @org.arquillian.example@ package and name it @GreeterTest@. You won't need the typical setup and teardown methods since Arquillian is doing most of the heavy lifting. Here's what we have so far:

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.junit.Assert;
import org.junit.Test;

public class GreeterTest {
    @Test
    public void should_create_greeting() {
        Assert.fail("Not yet implemented");
    }
}

p. Now, about that flair. An Arquillian test case must have three things:

# A @@RunWith(Arquillian.class)@ annotation on the class
# A static method annotated with @@Deployment@ that returns a ShrinkWrap archive
# At least one method annotated with @@Test@

The @@RunWith@ annotation tells JUnit to use Arquillian as the test controller. Arquillian then looks for a static method annotated with the @@Deployment@ annotation to retrieve the test archive (i.e., micro-deployment). Then some magic happens and each @@Test@ method is run inside the container environment.

h4. What's a test archive?

The purpose of the test archive is to isolate the classes and resources which are needed by the test from the remainder of the classpath. Unlike a normal unit test, Arquillian does not simply dip into the entire classpath. Instead, you include only what the test needs (which may be the entire classpath, if that's what you decide). The archive is defined using "ShrinkWrap":shrinkwrap_home, which is a Java API for creating archives (e.g., jar, war, ear) in Java. The micro-deployment strategy let's you focus on precisely the classes you want to test and, as a result, the test remains very lean.

p(info). %ShrinkWrap also supports resolving artifacts (libraries) and create configuration files programmatically, which can then be added to the test archive. For a more thorough introduction to ShrinkWrap, see the "ShrinkWrap introduction":/guides/shrinkwrap_introduction guide.%

Let's add that Arquillian flair to the test:

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class GreeterTest {

    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(Greeter.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Test
    public void should_create_greeting() {
        Assert.fail("Not yet implemented");
    }
}

p. Using ShrinkWrap, we've defined a Java archive (jar) as the deployment that includes the @Greeter@ class that the test will invoke and an empty beans.xml in the META-INF directory to activate CDI in this archive.

Now all we need to do is inject the @Greeter@ instance into a field directly above the test method and replace the unimplemented test method with one that asserts the behavior of the bean. To give you that warm fuzzy feeling, we'll also print the greeting to the console.

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. // clip
@Inject
Greeter greeter;

@Test
public void should_create_greeting() {
    Assert.assertEquals("Hello, Earthling!",
        greeter.createGreeting("Earthling"));
    greeter.greet(System.out, "Earthling");
}

p. Here's how the test should look when you're done:

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Test;
import org.junit.Assert;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class GreeterTest {

    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(Greeter.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Inject
    Greeter greeter;

    @Test
    public void should_create_greeting() {
        Assert.assertEquals("Hello, Earthling!",
            greeter.createGreeting("Earthling"));
        greeter.greet(System.out, "Earthling");
    }
}

p. You've written your first Arquillian test! Ah, but you're probably wondering how to run it ~:S If you're thinking, "Just like a unit test" you're correct! However, we first need to add a container adapter to the classpath.

h3. Add a Container Adapter

We've been talking a lot about testing in a container, but so far we have mentioned which one. That's because it's a runtime decision.

Arquillian selects the target container based on which container adapter is available on the test classpath. That means we'll be adding more libraries to the project.

An Arquillian test can be executed in any container that is compatible with the programming model used in the test (as long as the container has an Arquillian adapter). Our test is using the CDI programming model, so we need to use any container to supports CDI. We want fast turnaround during development, so we'll start with the Weld EE embedded container.

Open the @pom.xml@ file again and add the following group of dependencies directly below the other @<dependency>@ elements:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.container</groupId>
    <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
    <version>1.0.0.CR2</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.jboss.weld</groupId>
    <artifactId>weld-core</artifactId>
    <version>1.1.1.Final</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-simple</artifactId>
    <version>1.5.10</version>
    <scope>test</scope>
</dependency>
<!-- clip -->

p. To summarize, here are the three libraries you need to use Arquillian (with JUnit):

# Arquillian JUnit integration
# Arquillian container adapter for the target container
# Container runtime (embedded container) or container client (remote container)

We're using an embedded container in this example, so we need the container runtime, Weld.

Now back to the test.

h3. Run the Arquillian Test

Once you add all the necessary Arquillian libraries to the classpath, you can run an Arquillian test just like a unit test, whether you are running it from the IDE, the build script or any other test plugin. Let's run the test in Eclipse.

From the IDE window, right click on the GreeterTest.java file in the Package Explorer (or in the editor) and select Run As > JUnit Test from the context menu.

!/images/guides/arquillian_tutorial_run_junit_test.png!

When you run the test, you should see the following lines printed to the console:

bc(output). 26 [main] INFO org.jboss.weld.Version - WELD-000900 1.1.1 (Final)
Hello, Earthling!

You should then see the JUnit view appear, revealing a *(greenbar)green bar*!

!/images/guides/arquillian_tutorial_junit_green_bar.png!

You can also run the test on the commandline using Maven:

bc(command). $ mvn test

You should see the following lines printed to the console:

bc(output). -------------------------------------------------------
T E S T S
-------------------------------------------------------
Running org.arquillian.example.GreeterTest
21 [main] INFO org.jboss.weld.Version - WELD-000900 1.1.1 (Final)
Hello, Earthling!
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.858 sec

*Congratulations!* You've earned your first *(greenbar)green bar* with Arquillian!

h3. A Closer Look

How do you know that CDI really worked? For all you know, Arquillian created a new instance of the @Greeter@ class and injected it into the test without any involvement from CDI. Let's prove it's there.

Create a new CDI bean named @PhraseBuilder@ in the @org.arquillian.example@ package that can create phrases from templates.

div(filename). src/main/java/org/arquillian/example/PhraseBuilder.java

bc(prettify).. package org.arquillian.example;

import java.text.MessageFormat;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.PostConstruct;

public class PhraseBuilder {
    private Map<String, String> templates;

    public String buildPhrase(String id, Object... args) {
        return MessageFormat.format(templates.get(id), args);
    }

    @PostConstruct
    public void initialize() {
        templates = new HashMap<String, String>();
        templates.put("hello", "Hello, {0}!");
    }
}

p. Next, open up the @Greeter@ class and create a new constructor that will inject @PhraseBuilder@ using constructor injection. Then, delegate the task of creating the greeting to the injected bean.

div(filename). src/main/java/org/arquillian/example/Greeter.java

bc(prettify).. package org.arquillian.example;

import java.io.PrintStream;
import javax.inject.Inject;

public class Greeter {

    private PhraseBuilder phraseBuilder;

    @Inject
    public Greeter(PhraseBuilder phraseBuilder) {
        this.phraseBuilder = phraseBuilder;
    }

    public void greet(PrintStream to, String name) {
        to.println(createGreeting(name));
    }

    public String createGreeting(String name) {
        return phraseBuilder.buildPhrase("hello", name);
    }
}

p. Now, in order for the test to work, an instance of @PhraseBuilder@ must be created, its @@PostConstruct@ method invoked and must be injected into the constructor of @Greeter@ when an instance of @Greeter@ is created. We can be certain CDI is at work if all that comes together.

p. One last step.  Because we created a new class, we must be sure that it's getting added to the archive returned by the @@Deployment@ method in the test.  Simply change the line:

bc(prettify).. .addClass(Greeter.class)

p. ...to read:

bc(prettify).. .addClasses(Greeter.class, PhraseBuilder.class)

p. Run the test again. You should get another *(greenbar)green bar*! Feels good, doesn't it?

h3. Debug the Test

This is going to be a short chapter. Why? Because an Arquillian test is so straightforward that you debug it exactly how you debug a unit test. Just add a breakpoint anywhere--either in the test or in the application code. Then right click on the file and select Debug As > JUnit Test. You're now debugging in the container! Have fun poking around!

!/images/guides/arquillian_tutorial_debugging_test.png!

p(warning). %If you're using a remote container, Debug As does not cause breakpoints to be activated. Instead, you need to start the container in debug mode and attach the debugger. That's because the test is run in a different JVM than the original test runner.%

As you've just witnessed, Arquillian is the ideal tool for testing CDI applications. It takes care of loading the CDI environment and injecting beans directly into the test. Best of all, when using an embedded CDI container, the test runs just as quickly as a unit test. If that's all you need, then you can exit the tutorial now and start writing tests.

*But!* Is the embedded container telling the whole story? Will the component work if running inside a full container?

One of the perks of Arquillian is that you can run the same test in different compatible containers, whether it's another embedded container or a standalone container. If you intend to use multiple containers, read on.

h3. Add More Containers

As you learned earlier, Arquillian selects the container based on which container adapter is on the classpath. To switch to another container, you just change which container adapter is on the classpath before you run the test.

p(important). %There can only be one container adapter on the classpath at a given time.%

One way to swap the libraries on the classpath is to manually edit the dependencies defined in the @pom.xml@ each time. But that's just crazy. There's a much better way.

We can use Maven profiles to partition the dependencies into groups, one group for each container adapter and its related artifacts. When running the tests, you activate one of those groups to select the container using either a commandline flag (-P) or a preference in the IDE.

Open up the @pom.xml@ and create a new profile for Weld EE embedded by inserting the following XML directly under the @<dependencies>@ element:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profiles>
    <profile>
        <id>arquillian-weld-ee-embedded</id>
        <dependencies>
            <dependency>
                <groupId>org.jboss.spec</groupId>
                <artifactId>jboss-javaee-6.0</artifactId>
                <version>1.0.0.Final</version>
                <type>pom</type>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.arquillian.container</groupId>
                <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
                <version>1.0.0.CR2</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.weld</groupId>
                <artifactId>weld-core</artifactId>
                <version>1.1.1.Final</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-simple</artifactId>
                <version>1.5.10</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </profile>
</profiles>
<!-- clip -->

p. Next, *remove* the @jboss-javaee-6.0@ dependency and the dependencies for the Weld EE embedded container adapter from the main @<dependencies>@ section. Here's how the @<dependencies>@ and @<profiles>@ sections should look when you're done:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.8.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.jboss.arquillian.junit</groupId>
        <artifactId>arquillian-junit-container</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
<profiles>
    <profile>
        <id>arquillian-weld-ee-embedded</id>
        <dependencies>
            <dependency>
                <groupId>org.jboss.spec</groupId>
                <artifactId>jboss-javaee-6.0</artifactId>
                <version>1.0.0.Final</version>
                <type>pom</type>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.arquillian.container</groupId>
                <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
                <version>1.0.0.CR2</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.weld</groupId>
                <artifactId>weld-core</artifactId>
                <version>1.1.1.Final</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-simple</artifactId>
                <version>1.5.10</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </profile>
</profiles>
<!-- clip -->

p(info). %The Java EE API dependency has been moved to the profile since some containers, like Embedded GlassFish, already provide these libraries. Having both on the classpath at the same time would result in conflicts. So we have to play this classpath dance.%

We'll now include two additional profiles in the @pom.xml@ inside the @<profiles>@ element, the first for "Embedded GlassFish":http://embedded-glassfish.java.net:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-glassfish-embedded</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian.container</groupId>
            <artifactId>arquillian-glassfish-embedded-3.1</artifactId>
            <version>1.0.0.CR1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.glassfish.extras</groupId>
            <artifactId>glassfish-embedded-all</artifactId>
            <version>3.1</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p. and the other for JBoss AS managed:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-jbossas-managed</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.as</groupId>
            <artifactId>jboss-as-arquillian-container-managed</artifactId>
            <version>7.0.2.Final</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p. Now you have the choice of running the tests in one of three containers.

p. If you're having trouble with the pom.xml up to this point, you can download the file from "this gist":https://gist.github.com/1263934.

h3. Test Across Containers

When you refresh the project in Eclipse, you'll notice that it no longer builds. That's because you need to activate one of the container profiles. Let's activate the Weld EE embedded profile to restore the previous state.

There are two ways to activate a Maven profile in Eclipse:

# Manual configuration (standard approach)
# Maven profile selector (JBoss Tools)

h4. Set active Maven profile: Manual configuration

To set the active profile manually, follow these steps:

# Right click on the project and select Properties
# Select the Maven properties tab
# Enter the profile id in the Active Maven Profiles field (e.g., @arquillian-weld-ee-embedded@)
# Click the OK button and accept the project changes

Here's the Maven properties screen showing the profile we've activated:

!/images/guides/arquillian_tutorial_maven_properties.png!

h4. Set active Maven profile: Maven profile selector

If you have JBoss Tools installed, selecting the active profile becomes much easier:

# Right click on the project and select Maven > Select Active Profiles...
(alternatively, you can use the keybinding Ctrl+Shift+P or the button in the toolbar)
# Check the box next to the profile you want to activate (e.g., @arquillian-weld-ee-embedded@)
# Click the OK button

Here's the Maven profile selector dialog showing the profile we've activated:

!/images/guides/arquillian_tutorial_maven_profile_selector.png!

Once you've activate the profile, you should be able to run the test again successfully.

You already know the test works in Weld EE Embedded. Let's switch to GlassFish embedded by repeating the steps above, this time activating only the @arquillian-glassfish-embedded@ profile. Run the test again. You should see GlassFish start in the console...and another *(greenbar)green bar*!

You've now run the same test on two different embedded containers, a CDI container (Weld) and a Java EE container (GlassFish). Both of these executions are in process. To really be sure the component works in a pure environment, we need to use a standalone container. Let's switch to using JBoss AS.

To run the test on a standalone instance of JBoss AS, you first need to set it up. You can either:

# download and unpack it in a location outside the project or
# you can have Maven download and unpack it during a build.

Follow these steps to setup JBoss AS 7 outside the project:

# "Download JBoss AS 7":as7_download
(be sure the version you select matches the version you've defined in your @pom.xml@ for @<artifactId>jboss-as-arquillian-container-managed</artifactId>@)
# Extract the archive
# (optional) Set the @JBOSS_HOME@ environment variable to the path of the extracted directory

To have Maven handle this task for you instead, add the following XML fragment under the @<id>@ element of the @arq-jbossas-managed@ profile:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<build>
    <plugins>
        <plugin>
            <artifactId>maven-dependency-plugin</artifactId>
            <executions>
                <execution>
                    <id>unpack</id>
                    <phase>process-test-classes</phase>
                    <goals>
                        <goal>unpack</goal>
                    </goals>
                    <configuration>
                        <artifactItems>
                            <artifactItem>
                                <groupId>org.jboss.as</groupId>
                                <artifactId>jboss-as-dist</artifactId>
                                <version>7.0.2.Final</version>
                                <type>zip</type>
                                <overWrite>false</overWrite>
                                <outputDirectory>target</outputDirectory>
                            </artifactItem>
                        </artifactItems>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build> 
<!-- clip -->

p. To target a managed JBoss AS 7 instance, you also need a small bit of Arquillian configuration. Create the following configuration file and assign the value of the @jbossHome@ property to the location where JBoss AS 7 is installed. If you're using the Maven dependency plugin, the location is @target/jboss-as-7.0.2.Final@.

div(filename). src/test/resources/arquillian.xml

bc(prettify).. <arquillian xmlns="http://jboss.org/schema/arquillian"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://jboss.org/schema/arquillian
        http://jboss.org/schema/arquillian/arquillian_1_0.xsd">
    <container qualifier="jbossas-7-managed" default="true">
        <configuration>
            <property name="jbossHome">target/jboss-as-7.0.2.Final</property>
        </configuration>
    </container>
</arquillian>

p. Now change the active Maven profile to @arquillian-jbossas-managed@, then run the test again. You should see JBoss AS starting in the console...and yet another *(greenbar)green bar*!

p(info). %The message printed to System.out gets written to the server log instead of the console.%

That's the _same_ test, this time running in a standard (non-embedded) Java EE container. Arquillian packages the test, deploys to the container as a Java EE archive, executes the tests remotely, captures the results and feeds them back to the Eclipse JUnit result view (or in the Maven surefire results). You can read more about how this lifecycle works in the "Arquillian reference guide":https://docs.jboss.org/author/display/ARQ/Negotiating+test+execution.
