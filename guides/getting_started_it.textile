---
layout: guide
title: Guida introduttiva
authors: [mojavelinux]
translators: [flashboss]
tags: [cdi, weld, maven, forge, eclipse]
description: Impariamo ad aggiungere Arquillian alla suite di test del nostro progetto e scrivere il nostro primo test.
guide_group: 1
guide_order: 10
---
[forge_home]http://jboss.org/forge
[forge_download]https://repository.jboss.org/nexus/service/local/artifact/maven/redirect?r=releases&g=org.jboss.forge&a=forge-distribution&v=1.0.0.Final&e=zip
[maven_home]http://maven.apache.org
[maven_download]http://maven.apache.org/download.html
[maven_search]http://search.maven.org
[jdk_download]http://www.oracle.com/technetwork/java/javase/downloads
[as7_download]http://jboss.org/jbossas/downloads
[tools_home]http://jboss.org/tools
[shrinkwrap_home]http://jboss.org/shrinkwrap
[m2e_home]http://eclipse.org/m2e

Questa guida introduce Arquillian. Alla fine della lettura, potrai:

* Aggiungere l'infrastruttura di Arquillian ad un progetto basato su Maven
* Scrivere un test di Arquillian che lavora su un bean CDI(Contexts and Dependency Injection)
* Eseguire i test di Arquillian su container multipli tramite Maven ed Eclipse

Queste capacità verranno apprese incorporando Arquillian in una suite di test di un'applicazione Java EE basata su Maven. Abbiamo ideato questa guida in modo da essere di _semplice lettura_ per farti subito iniziare!

h3. Presupposti

Il modo più semplice di usare Arquillian è incorporarlo nella suite di test di un progetto usando un tool di build basato su dipendenze. Oggi, il più usato tool di questo tipo è "Apache Maven":maven_home. Questa guida vi porterà alla vostra prima *(greenbar)green bar* usando un progetto Maven.

p(info). %Arquillian non è legato nè a Maven, nè ad alcun altro tool di building. Può lavorare anche--se non meglio--con progetti basati su Ant o Gradle. E' preferibile un tool di dependency management poichè semplifica l'inclusione delle librerie di Arquillian che sono già distribuite nel "Maven Central repository":maven_search.% 

This guide assumes you have Maven available, either in your command shell or your IDE(Integrated Development Environment). If you don't, please "download and install Maven now":maven_download. You'll also need "JDK(Java Development Kit) 1.5":jdk_download or higher installed on your machine, though JDK 1.6 is preferred.

Questa guida presuppone che abbiate Maven disponibile nella shell dei comandi oppure nell'IDE(Integrated Development Environment). Altrimenti, eseguite il "download e installazione di Maven":maven_download. Avrete bisogno della "JDK(Java Development Kit) 1.5":jdk_download o superiore installata nella vostra macchina, sebbene sia preferibile la JDK 1.6.

h3. Creare un Nuovo Progetto

Ci sono due modi che raccomandiamo di usare per creare un nuovo progetto Maven:

# "Generare un progetto da un Archetype di Maven":#generate_project_from_archetype
# "Creare e personalizzare un progetto tramite JBoss Forge":#create_project_using_forge

"JBoss Forge":forge_home è di gran lunga il più semplice, ma questa guida offre entrambe le opzioni nel caso non vi sentiate pronti a usare JBoss Forge. Selezionate una delle due opzioni per saltare alle istruzioni.

p(info). %Se avete un progetto Maven già pronto, potete usare questa sezione per confrontarlo e assicurarvi che tutte le dipendenze siano presenti prima di iniziare.%

h4(#generate_project_from_archetype). Generare un Progetto da un Archetype di Maven

Per prima cosa, creiamo un progetto Java basato su Maven con il seguente comando:

bc(command).. $ mvn archetype:generate -DarchetypeGroupId=net.avh4.mvn.archetype \
-DarchetypeArtifactId=java-1.6-archetype

p. _Copiate il testo dopo il @$@ e copiatelo nella vostra shell dei comandi_. Al prompt, inserite il valore mostrato dopo ogni virgoletta nel pannello in basso. Premete Enter dopo ogni valore (come indicato da @<ENTER>@).

bc(output). Define value for property 'groupId': : org.arquillian.example <ENTER>
Define value for property 'artifactId': : arquillian-tutorial <ENTER>
Define value for property 'version': : <ENTER>
Define value for property 'package': : <ENTER>
Confirm properties configuration:
groupId: org.arquillian.example
artifactId: arquillian-tutorial
version: 1.0-SNAPSHOT
package: org.arquillian.example
Y: : <ENTER>

p. Il comando ha creato un progetto Maven dentro la directory corrente in una nuova directory chiamata @arquillian-tutorial@. Entriamo in questa nuova directory. La struttura dei file del progetto è mostrata in basso.

(filetree)* src/
** main/
*** java/ - Quì vanno tutti i file sorgenti Java dell'applicazione (sotto il package Java)
*** resources/ - Quì vanno tutti i file di configurazione dell'applicazione
** test/
*** java/ - Quì vanno tutti i sorgenti Java delle classi di test (sotto il package Java)
*** resources/ - Quì vanno tutti i file di configurazione dei test (p.es., arquillian.xml)
* pom.xml - Il file di build di Maven. Istruisce Maven su come deve essere costruito il progetto.

Il generatore del progetto ha creato anche un package Java con nome @org.arquillian.example@ sotto le due directory @java@. Quì dovrete mettere tutti i sorgenti Java invece di usare la root come directory @java@.

Andiamo avanti e apriamo il @pom.xml@ nel nostro editor. Dovreste vedere un file XML contenente le informazioni base del progetto, una sezione build e una sezione dependencies.

p(info). %Noterete che il progetto è configurato con Java 1.6 e JUnit 4.8, rispettivamente le versioni minime di Java e JUnit raccomandate da Arquillian.%

p(warning). %Arquillian supporta anche TestNG 5 ma in questa guida ci limiteremo a usare JUnit%

*Tutti gli elementi @<dependency>@ sotto la dependency JUnit possono essere rimosse se non richieste.* Dopo questa modifica, il file dovrebbe diventare uguale al contenuto quì in basso (leggermente riformattato):

div(filename). pom.xml

bc(prettify).. <?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.arquillian.example</groupId>
    <artifactId>arquillian-tutorial</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>arquillian-tutorial</name>
    <url>http://arquillian.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>

p. Iniziamo ora a scrivere i componenti Java EE 6. Abbiamo quindi bisogno di aggiungere le API Java EE 6 al classpath in modo da poterli compilare.

Apriamo nuovamente il file @pom.xml@ e aggiungiamo il seguente frammento XML direttamente dentro l'elemento @<dependencies>@. Quì in basso vediamo come dovrebbe diventare l'elemento @<dependencies>@ una volta terminato:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>org.jboss.spec</groupId>
        <artifactId>jboss-javaee-6.0</artifactId>
        <version>1.0.0.Final</version>
        <type>pom</type>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.8.1</version>
        <scope>test</scope>
    </dependency>
</dependencies>
<!-- clip -->

p(important). %L'artifact @org.jboss.spec:jboss-javaee-6.0@ contiene soltanto le API standard di Java EE 6. Raccomandiamo *fortemente* di *non usare* l'artifact delle API Java EE con coordinate @javax:javaee-api@. L'ultimo artifact contiene classi con il corpo dei metodi ridotto all'osso, le quali causano all'applicazione di lanciare errori oscuri di codice assente se aggiunte a runtime nel classpath (perfino durante l'esecuzione dei test). "Leggete queste FAQ":https://community.jboss.org/wiki/WhatsTheCauseOfThisExceptionJavalangClassFormatErrorAbsentCode per più dettagli.%

p. La base del progetto è pronta! Saltiamo alla sezione, "Aprire il Progetto con Eclipse":#open_the_project_in_eclipse, in modo da iniziare a scrivere codice!

h4(#create_project_using_forge). Creare un Progetto Con Forge

"JBoss Forge":forge_home è una shell di comandi per creare rapidamente applicazioni in modo standard. Possiamo considerarlo un Maven Archetypes con gli steroidi.

Installing Forge is a relatively short process, and this guide will take you through the fundamentals. Follow these simple steps to get Forge installed:

L'installazione di Forge è molto rapida, e questa guida ne spiegherà i passi fondamentali. Seguite questi semplici passaggi per installare Forge:

# "Scarichiamo Forge":forge_download
# Eseguiamo l'unzip della distribuzione in una directory del nostro harddrive, che chiameremo @$FORGE_HOME@
  Presupponiamo che la distribuzione sia stata estratta in una directory con nome @forge@
# Aggiungiamo @$FORGE_HOME/bin@ nel nostro path (Windows, Linux o Mac OSX)

Su sistemi operativi basati su Unix, aggiungere Forge al path significa solitamente di editare i file $HOME/.bashrc o $HOME/.profile; avremo bisogno di aggiungere le seguenti variabili di ambiente:

bc(command). $ export FORGE_HOME=$HOME/forge/
$ export PATH=$PATH:$FORGE_HOME/bin

p(info). %Su Windows, bisogna aprire il "Pannello di Controllo", cliccare su "Proprietà di Sistema", aprire il tab "Avanzate", cliccare su "Variabili d'Ambiente" e aggiungere visualmente le due variabili. Raccomandiamo di impostare queste variabili per Forge, a meno che non venga fatto l'unzip della distribuzione in una directory accessibile a tutti gli utenti.%

Ora che Forge è installato (o meglio, estratto), accediamo ad un prompt dei comandi della shell e lanciamo il comando @forge@:

bc(command).. $ forge
   _____                    
  |  ___|__  _ __ __ _  ___ 
  | |_ / _ \| `__/ _` |/ _ \  \\
  |  _| (_) | | | (_| |  __/  //
  |_|  \___/|_|  \__, |\___| 
                  |___/      
 
[no project] ~ $

p. Questo è tutto! Abbiamo lanciato e attivato Forge. Ora è tempo di creare il progetto.

Nella shell di Forge, eseguiamo il seguente comando per creare un progetto vuoto, molto simile a come abbiamo creato precedentemente il progetto con Maven Archetype:

bc(command). $ new-project --named arquillian-tutorial --topLevelPackage org.arquillian.example

p. Questo comando genera un progetto basato su Maven in una nuova directory con nome @arquillian-tutorial@ sotto la directory corrente.

La struttura dei file del progetto generato da Forge è mostrato in basso: 

(filetree)* src/
** main/
*** java/ - Quì vanno tutti i file sorgenti Java dell'applicazione (sotto il package Java)
*** resources/ - Quì vanno tutti i file di configurazione dell'applicazione
**** META-INF/
***** forge.xml - Il file di configurazione di Forge vuoto
** test/
*** java/ - Quì vanno tutti i sorgenti Java delle classi di test (sotto il package Java)
*** resources/ - Quì vanno tutti i file di configurazione dei test (p.es., arquillian.xml)
* pom.xml - Il file di build di Maven. Istruisce Maven su come deve essere costruito il progetto.

Forge fa in modo che la directory del progetto diventi la directory corrente all'interno della shell. 

bc(command). [arquillian-tutorial] arquillian-tutorial $ 

Per default, Forge configura il progetto con Java 1.6, la versione minima di Java raccomandata da Arquillian, piuttosto comodo.

Bisogna ora aggiungere le API di Java EE. Viene fatto tramite il comando @project add-dependency@ mostrato quì in basso:

bc(command). $ project add-dependency org.jboss.spec:jboss-javaee-6.0:1.0.0.Final:provided:pom

Bisogna anche aggiungere la dipendenza di JUnit 4.8, la versione minima richiesta da Arquillian, con scope di tipo test:

bc(command). $ project add-dependency junit:junit:4.8.1:test

Forge aggiunge il repository della Community JBoss nel file pom.xml. Questo repository non è indispensabile per Arquillian. (E' preferibile comunque mantenerlo se si necessitano altre librerie della Community JBoss). Se si vuole rimuovere il repository, è sufficiente usare il seguente comando di Forge:

bc(command). $ project remove-repository http://repository.jboss.org/nexus/content/groups/public 

Il risultato del pom.xml generato da Forge è mostrato quì in basso:

div(filename). pom.xml

bc(prettify).. <?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xsi:schemaLocation="
        http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.arquillian.example</groupId>
    <artifactId>arquillian-tutorial</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <build>
        <finalName>arquillian-tutorial</finalName>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

p. Il progetto base è pronto! Apriamo ora il progetto con Eclipse in modo da iniziare a scrivere del codice!

h3. Aprire il Progetto con Eclipse

Quando si sviluppa un progetto Java, è preferibile usare un IDE come Eclipse. Questo perchè Arquillian è progettato per essere IDE friendly. Si possono lanciare i test di Arquillian dall'IDE senza configurazioni particolari. Diamo subito uno sguardo ai vantaggi forniti dall'IDE.

Prima di Lanciare Eclipse, siccome il nostro è un progetto Maven, abbiamo bisogno di installare il plugin "Maven Integration for Eclipse":m2e_home (m2e), se non presente. 

h4. Installare il plugin m2e

Se il plugin non è ancora installato, è preferibile installare "JBoss Tools":tools_home. Seguite questi passaggi per installarlo tramite l'Eclipse Marketplace (E' una specie di app store per Eclipse).

# Selezionare @Help > Eclipse Marketplace...@ dal menù principale
# Digitare "jboss tools" (senza virgolette) nel campo Find, e premere Enter
# Cliccare il bottone Install vicino a JBoss Tools (Indigo)
# Completare il wizard di installazione e riavviare Eclipse appena terminato

JBoss Tools fornisce un buon ambiente per sviluppare applicazioni Java EE, includendo un ottimo supporto per CDI. Nonostante sia molto leggero, è un plugin molto potente.

Comunque, se volete soltanto la parte di integrazione con Maven senza gli extra di JBoss Tools, potete seguire questi passaggi:

# Selezionare @Help > Eclipse Marketplace...@ dal menù principale
# Digitare "maven" (senza virgolette) nel campo Find, e premere Enter
# Cliccare il bottone Install vicino a Maven Integration for Eclipse
# Complete the install wizard, then restart Eclipse if prompted
# Completare il wizard di installazione e riavviare Eclipse appena terminato
# Ripetere gli stessi passaggi per installare il plugin Maven Integration for Eclipse WTP

h4. Usare m2e per importare il progetto

Una volta che il plugin Maven è installato, seguite questi passaggi per aprire il progetto:

# Selezionare @Help > Eclipse Marketplace...@ dal menù principale
# Digitare "existing maven" (senza virgolette) nel campo di import dei sorgenti
# Selezionare l'opzione Existing Maven Projects, e cliccare su Next
# Cliccare sul bottone Browse...
# Navigare nella directory del progetto nel file browser, selezionarlo, e cliccare sul bottone OK
# Cliccare su Finish per aprire il progetto

Eclipse riconoscerà il progetto Maven e lo aprirà nella vista del Project Navigator. Se si espande il progetto, avremo un'ammagine simile:

!/images/guides/arquillian_tutorial_eclipse_project.png!

Ora possiamo tornare al lavoro!

h3. Creare un Componente

Per scrivere un test di Arquillian, abbiamo bisogno prima di un componente da testare. Creiamo un componente base in modo da imparare subito il funzionamento di Arquillian senza altre distrazioni. Gradualmente ci muoveremo verso scenari più complessi. 

Nell'IDE, create una nuova classe Java con nome @Greeter@ nel package @org.arquillian.example@. Sostituite i contenuti del file con la seguente logica del greeter:

div(filename). src/main/java/org/arquillian/example/Greeter.java

bc(prettify).. package org.arquillian.example;

import java.io.PrintStream;

/**
 * A component for creating personal greetings.
 */
public class Greeter {
    public void greet(PrintStream to, String name) {
        to.println(createGreeting(name));
    }

    public String createGreeting(String name) {
        return "Hello, " + name + "!";
    }
}

p. Lo scopo è di verificare che questa classe si comporti nel modo giusto quando viene invocata tramite un bean CDI(Contexts and Dependency Injection). Naturalmente, lo facciamo scrivendo un semplice test di unità. Abbiamo però bisogno che il bean utilizzi i servizi enterprise come la dependency injection e il messaging e che venga usato da dentro un container. (Inoltre gli daremo spazio per crescere ~;))

Per usare la classe come bean CDI, abbiamo bisogno di ereditarlo dal test tramite l'annotazione@@Inject@. E verrà fatto dal test di Arquillian! Ora è tempo di aggiungere le API di Arquillian al progetto!  

h3. Aggiungere e API di Arquillian

Aprite nuovamente con l'editor il @pom.xml@ che si trova nella root del progetto. Abbiamo bisogno di istruire Maven sulle versioni degli artifact da usare. Inserite il seguente frammento XML direttamente sopra all'elemento @<build>@ per importare il BOM(Bill of Materials). Il BOM permette di importare una distribuzione completa del prodotto, stabilendo con precisione le versioni compatibili delle dipendenze.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian</groupId>
            <artifactId>arquillian-bom</artifactId>
            <version>#{site.components['arquillian-core'].latest_version}</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
    </dependencies>
</dependencyManagement>
<!-- clip -->

p. Poi, appendete il seguente frammento XML direttamente sotto l'ultimo elemento @<dependency>@ per aggiungere la parte di integrazione con JUnit di Arquillian:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.junit</groupId>
    <artifactId>arquillian-junit-container</artifactId>
    <scope>test</scope>
</dependency>
<!-- clip -->

p. L'artifact per l'integrazione con JUnit di Arquillian aggiunge anche la Core Arquillian e le API di ShrinkWrap nel classpath dei test. Queste librerie sono necessarie per scrivere e compilare i test.

p(info). %Per usare TestNG al posto di JUnit, sostituite l'artifact di integrazione con JUnit con l'artifact di integrazione con TestNG.%

(Optional) E' raccomandato aggiornare il Maven Surefire Plugin invece di usare la versione di default, per i motivi descritti in "queste FAQ":https://community.jboss.org/wiki/WhatVersionOfSurefireShouldIUseToRunMyArquillianTestsInAMavenBuild. Potete modificare la versione del Surefire Plugin appendendo questo elemento @<plugin>@ nell'elemento @<plugins>@, subito sotto al Maven Compiler Plugin: 

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<plugin>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.12</version>
</plugin>
<!-- clip -->

p. Se si hanno problemi con il pom.xml a questo punto, potete scaricare il file "pom-no-container-profiles.xml":https://raw.github.com/arquillian/arquillian-examples/master/arquillian-tutorial/pom-no-container-profiles.xml dal "progetto di esempio":https://github.com/arquillian/arquillian-examples/tree/master/arquillian-tutorial e rinominarlo in pom.xml.

*Ci sono ora tutti i requisiti per scrivere il primo test di Arquillian!*

h3. Scrivere un Test con Arquillian

Un test Arquillian è identico a un test JUnit, ma con degli extra. Torniamo all'IDE per crearne uno.

p(warning). %Se compare il messaggio "Project configuration is out of date with pom.xml" andate cliccando con il tasto destro su Project > Maven > Update Project Configuration to resync the project.%

Cominciamo a create un nuovo test JUnit in src/test/java con nome @GreeterTest@ e assegnamogli un package con nome @org.arquillian.example@. Non ci sarà bisogno dei tipici metodi JUnit di setup e tearDown dal momento che tutto sarà gestito da Arquillian. Quì in basso c'è tutto quello di cui abbiamo bisogno:

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.junit.Assert;
import org.junit.Test;

public class GreeterTest {
    @Test
    public void should_create_greeting() {
        Assert.fail("Not yet implemented");
    }
}

p. Un test Arquillian deve avere necessariamente tre cose: 

# Un'annotazione @@RunWith(Arquillian.class)@ sulla classe
# Un metodo statico pubblico annotato con @@Deployment@ che ritorna un archivio di ShrinkWrap
# Almeno un metodo annotato con @@Test@

L'annotazione @@RunWith@ dice a JUnit di usare Arquillian come test controller. Arquillian cerca in seguito un metodo statico pubblico annotato con l'annotazione @@Deployment@ per ricevere l'archivio di test (p.es., micro-deployment). Così automaticamente ogni metodo @@Test@ girerà dietro un container.

h4. Cos'è un archivio di test?

Lo scopo dell'archivio di test è di isolare le classi e le risorse necessarie al test dal resto del classpath. Diversamente da un normale test unitario, il test di Arquillian non deve ereditare tutto il classpath del progetto. Al contrario, includerete soltanto quello che il test necessita (che può essere anche l'intero classpath, se lo decidete). L'archivio è definito usando "ShrinkWrap":shrinkwrap_home, che è una serie di API Java per creare archivi Java (p.es., jar, war, ear). La strategia del micro-deployment permette di focalizzarsi con precisione sulle classi che vogliamo testare. Come risultato, il test sarà molto leggero e maneggevole.

Una volta che l'archivio he ShrinkW è deployato sul server, è da considerare come un archivio reale. Il deployer del container non sa che sta per deployare un archivio ShrinkWrap. Si può pensare a ShrinkWrap come un tool di build basato su Java, con un'eccezione. Nel caso ottimale, passa l'archivio in stream sul server anzichè scriverlo su disco. Ma l'archivio è comunque autentico.

p(info). %ShrinkWrap supporta anche la risoluzione degli artifact (librerie) e crea i file di configurazione a livello programmatico, che possono essere ggiunti all'archivio di test. Per una più ampia introduzione a ShrinkWrap, vedete "ShrinkWrap introduction":/guides/shrinkwrap_introduction guide.%

Aggiungiamo il miglioramento al test sostituendo i suoi contenuti con i seguenti:

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class GreeterTest {

    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(Greeter.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Test
    public void should_create_greeting() {
        Assert.fail("Not yet implemented");
    }
}

p. Usando ShrinkWrap, abbiamo definito un archivio Java (jar) come deployment. L'archvio include la classe @Greeter@ che il test invocherà e un beans.xml vuoto nella directory META-INF per attivare il CDI in quest'archivio.

Se volete vedere i contenuti dell'archivio che ShrinkWrap crea durante l'esecuzione del test, è possibile stampare l'archivio nel stdout (p.es., nella console) prima che ritorni.

bc(prettify).. @Deployment
public static JavaArchive createDeployment() {
    JavaArchive jar = ShrinkWrap.create(JavaArchive.class)
        .addClass(Greeter.class)
        .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    System.out.println(jar.toString(true));
    return jar;
}

p. Il metodo produce il seguente output quando il test viene lanciato:

bc(output). 2ac9cd28-a71a-479a-a785-750b40221766.jar:
/META-INF/
/META-INF/beans.xml
/org/
/org/arquillian/
/org/arquillian/example/
/org/arquillian/example/Greeter.class

ShrinkWrap assegna all'archivio un nome casuale dal momento che non è stato specificato esplicitamente. Vedremo altri dettagli sugli archivi nella guida successiva, "Guida Introduttiva: Rispolveriamo e Ripetiamo":/guides/getting_started_rinse_and_repeat/#export_the_deployment.

Ora tutto quello di cui si ha bisogno è ereditare l'istanza @Greeter@ in un campo direttamente sopra al metodo di test e sostituire il metodo non implementato con uno che testa il comportamento del bean. Per darvi qualche emozione in più, stamperemo anche i saluti nella console. Sostituiamo il metodo di test con il codice in basso e aggiungiamo un'importazione tramite il @javax.inject.Inject@.

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. // clip
import javax.inject.Inject;
// clip

@Inject
Greeter greeter;

@Test
public void should_create_greeting() {
    Assert.assertEquals("Hello, Earthling!",
        greeter.createGreeting("Earthling"));
    greeter.greet(System.out, "Earthling");
}

p. Here's how the test should look when you're done:

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import javax.inject.Inject;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Test;
import org.junit.Assert;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class GreeterTest {

    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(Greeter.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Inject
    Greeter greeter;

    @Test
    public void should_create_greeting() {
        Assert.assertEquals("Hello, Earthling!",
            greeter.createGreeting("Earthling"));
        greeter.greet(System.out, "Earthling");
    }
}

p. Avete scritto il vostro primo test di Arquillian!

Ah, ma ora vi starete chiedendo come lanciarlo ~:S Se state pensando, "Come un test unitario", allora siete nel giusto! Tuttavia, abbiamo prima bisogno di aggiungere un container adapter al classpath.

h3. Aggiungere un Container Adapter

Abbiamo parlato molto di test dentro un container, ma non di quali container andremo ad usare. La scelta del container viene decisa a runtime.

Arquillian seleziona il container di destinazione su cui è attivo il container adapter dal classpath del test. Un _container adapter_ è colui che controlla e comunica con il container (non è esso stesso un container). Questo significa che dobbiamo aggiungere nuove librerie al progetto.

Un test di Arquillian può essere eseguito in qualunque container compatibile con il modello di programmazione usato nel test (naturalmente, se in Arquillian esiste il corrispettivo adapter per il container). Il nostro test usa il modello di programmazione CDI, e quindi abbiamo bisogno di usare un container che supporti CDI. Vogliamo garantire velocità a questo test, quindi scegliamo il Weld EE embedded container. 

Aprite nuovamente il file @pom.xml@ e aggiungete il seguente gruppo di dipendenze direttamente sotto gli altri elementi @<dependency>@:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.container</groupId>
    <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
    <version>1.0.0.CR3</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.jboss.weld</groupId>
    <artifactId>weld-core</artifactId>
    <version>1.1.5.Final</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-simple</artifactId>
    <version>1.6.4</version>
    <scope>test</scope>
</dependency>
<!-- clip -->

p. Per riassumere, quì in basso abbiamo le tre libreire necessarie ad Arquillian (con JUnit):

# Arquillian JUnit integration
# Arquillian container adapter per il target container
# Container runtime (per un container integrato) o container client (per un container remoto)

In questo esempio stiamo usando un container integrato, quindi abbiamo bisogno del container runtime, Weld.

Torniamo ora al test.

h3. Lanciare il Test di Arquillian

Una volta che tutte le librerie necessarie ad Arquillian sono aggiunte nel classpath, si può lanciare il test sotto forma di test unitario da Eclipse, da uno script di build o da qualunque altro plugin predisposto ai test. Lanciamolo ora da Eclipse. 

Dalla finestra dell'IDE, tasto destro sul file GreeterTest.java nel Package Explorer (o nell'editor) e selezionate Run As > JUnit Test dal menù.

!/images/guides/arquillian_tutorial_run_junit_test.png!

Quando lanciate il test, dovreste vedere le seguenti linee nella console:

bc(output). 21 [main] INFO org.jboss.weld.Version - WELD-000900 1.1.5 (Final)
Hello, Earthling!

Dovreste poi veder apparire la vista di JUnit con una *(greenbar)barra verde*!

!/images/guides/arquillian_tutorial_junit_green_bar.png!

Il test si può lanciare anche con Maven da linea di comando:

bc(command). $ mvn test

Dovreste vedere le seguenti linee nella console:

bc(output). -------------------------------------------------------
T E S T S
-------------------------------------------------------
Running org.arquillian.example.GreeterTest
19 [main] INFO org.jboss.weld.Version - WELD-000900 1.1.5 (Final)
Hello, Earthling!
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.907 sec

*Congratulazioni!* E' comparsa la prima *(greenbar)barra verde* di Arquillian!

h3. Uno sguardo più da vicino

Come sappiamo che CDI lavora realmente? Per quello che sappiamo ora, Arquillian ha creato un'istanza della classe @Greeter@ ed ereditata dentro un test senza alcuna prova che sia stato eseguita un'implementazione CDI. Verifichiamo.

Creiamo un nuovo bean CDI con nome @PhraseBuilder@ nel package @org.arquillian.example@. La nuova classe crea delle frasi partendo da un template. 

div(filename). src/main/java/org/arquillian/example/PhraseBuilder.java

bc(prettify).. package org.arquillian.example;

import java.text.MessageFormat;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.PostConstruct;

public class PhraseBuilder {
    private Map<String, String> templates;

    public String buildPhrase(String id, Object... args) {
        return MessageFormat.format(templates.get(id), args);
    }

    @PostConstruct
    public void initialize() {
        templates = new HashMap<String, String>();
        templates.put("hello", "Hello, {0}!");
    }
}

p. Ora, apriamo la classe @Greeter@ e creiamo un nuovo costruttore che erediterà il @PhraseBuilder@ tramite l'injection del costruttore. Deleghiamo poi il compito di creare il saluto al nuovo bean ereditato.

div(filename). src/main/java/org/arquillian/example/Greeter.java

bc(prettify).. package org.arquillian.example;

import java.io.PrintStream;
import javax.inject.Inject;

public class Greeter {

    private PhraseBuilder phraseBuilder;

    @Inject
    public Greeter(PhraseBuilder phraseBuilder) {
        this.phraseBuilder = phraseBuilder;
    }

    public void greet(PrintStream to, String name) {
        to.println(createGreeting(name));
    }

    public String createGreeting(String name) {
        return phraseBuilder.buildPhrase("hello", name);
    }
}

p. Ora, per far si che il test funzioni, un'istanza del @PhraseBuilder@ deve essere creata, il suo metodo @@PostConstruct@ deve essere invocato ed ereditato dentro il costruttore del @Greeter@ al momento della creazione di un'istanza del @Greeter@. Se tutto questo avviene, siamo certi che CDI lavora come dovrebbe.

p. Come ultimo passaggio, dato che abbiamo creato una nuova classe, dobbiamo assicurarci che venga aggiunta all'archivio di test tramite il metodo @@Deployment@. Semplicemente dobbiamo cambiare questa linea:

bc(prettify).. .addClass(Greeter.class)

p. ...con:

bc(prettify).. .addClasses(Greeter.class, PhraseBuilder.class)

p. Lanciamo nuovamente il test. Si dovrebbe vedere nuovamente la *(greenbar)barra verde*! Non male, vero?

h3. Debug del Test

Questo sarà un capitolomolto breve. Perchè? Perchè un test Arquillian si mette in debug esattamente come un qualsiasi test unitario. Semplicemente aggiungiamo un breakpoint nel codice del test o di un altro componente dell'applicazione. Dopodichè clicchiamo con il tasto destro sul progetto e selezioniamo Debug As > JUnit Test. In questo modo stiamo eseguendo il debug nel container! Provatelo quanto volete!
  
!/images/guides/arquillian_tutorial_debugging_test.png!

p(warning). %Se si sta usando un container remoto, il Debug As non attiverà i breakpoint. Sarà invece necessario lanciare il container in modalità debug e agganciare manualmente il debugger. Questo perchè il test viene lanciato da una nuova JVM%

Come avete visto, Arquillian è il tool ideale per testare applicazioni CDI. Cura il caricamento dell'ambiente CDI ed eredita i bean CDI direttamente nei test. Meglio ancora, quando si usa un container CDI integrato, il test gira come un normale test unitario. Se questo è tutto quello di cui avete bisogno, potete uscire dal tutorial e iniziare a scrivere i vostri test.

*Ma un momento!* Parliamo soltanto del container integrato? Il componente girerà dietro un container completo?

Una delle perle di Arquillian è che il test può girare su differenti container, sia integrati che standalone. Se vogliamo provare un container più realistico, continuiamo a leggere questo documento.

h3. Aggiungere nuovi Container

Come abbiamo visto in precedenza, Arquilian seleziona il container a seconda dell'adapter che si trova nel classpath. Per cambiare container, è sufficiente cambiare il container adapter nel classpath prima di lanciare il test.

p(important). %Si può usare soltanto un container adapter alla volta. Se ci sono più container adapter nel classpath, Arquillian bloccherà l'esecuzione del test pichè determinerà un numero eccessivo di container adapter%

Un modo per eseguire lo switch del container adapter è quello di modificare le dependencies di Maven viste in precedenza nel @pom.xml@. Ma è piuttosto faticoso. L'approccio raccomandatoè di usare i profili Maven.

h4. Configurare i profili di Maven

I profili di Maven permettono di suddividere le dipendenze in gruppi, un gruppo per ogni container adapter e i suoi artifact correlati. Quando si lanciano i test, verrà attivato uno di questi gruppi, che selezionerà il relativo container. Il profilo può essere attivato sia dalla linea di comando tramite il flag (-P) che dalle preferenze dell'IDE.  

Apriamo il @pom.xml@ e creiamo un nuovo profilo per il Weld EE embedded inserendo il seguente frammento XML direttamente sotto all'elemento @<dependencies>@:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profiles>
    <profile>
        <id>arquillian-weld-ee-embedded</id>
        <dependencies>
            <dependency>
                <groupId>org.jboss.spec</groupId>
                <artifactId>jboss-javaee-6.0</artifactId>
                <version>1.0.0.Final</version>
                <type>pom</type>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.arquillian.container</groupId>
                <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
                <version>1.0.0.CR3</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.weld</groupId>
                <artifactId>weld-core</artifactId>
                <version>1.1.5.Final</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-simple</artifactId>
                <version>1.6.4</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </profile>
</profiles>
<!-- clip -->

p. *Rimuoviamo* poi la dependency @jboss-javaee-6.0@ e le altre dependency legate al Weld EE embedded container adapter dalla sezione @<dependencies>@. Una volta rimosse, le sezioni @<dependencies>@ e @<profiles>@ risulteranno simili al codice quì in basso:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.8.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.jboss.arquillian.junit</groupId>
        <artifactId>arquillian-junit-container</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
<profiles>
    <profile>
        <id>arquillian-weld-ee-embedded</id>
        <dependencies>
            <dependency>
                <groupId>org.jboss.spec</groupId>
                <artifactId>jboss-javaee-6.0</artifactId>
                <version>1.0.0.Final</version>
                <type>pom</type>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.arquillian.container</groupId>
                <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
                <version>1.0.0.CR3</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.weld</groupId>
                <artifactId>weld-core</artifactId>
                <version>1.1.5.Final</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-simple</artifactId>
                <version>1.6.4</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </profile>
</profiles>
<!-- clip -->

p(info). %La dipendenza Java EE API viene spostata nel profilo dal momento che alcuni container, come il GlassFish integrato, già integrano queste librerie. Avere le stesse librerie in entrambi i unti provoca conflitti. Bisogna perciò giocare con il classpath.%

Includiamo ora due nuovi profili nel @pom.xml@ dentro l'elemento @<profiles>@, il primo per il "GlassFish integrato":http://embedded-glassfish.java.net:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-glassfish-embedded</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian.container</groupId>
            <artifactId>arquillian-glassfish-embedded-3.1</artifactId>
            <version>1.0.0.CR3</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.glassfish.main.extras</groupId>
            <artifactId>glassfish-embedded-all</artifactId>
            <version>3.1.2</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p. e l'altro per JBoss AS:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-jbossas-managed</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.as</groupId>
            <artifactId>jboss-as-arquillian-container-managed</artifactId>
            <version>7.1.1.Final</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.arquillian.protocol</groupId>
            <artifactId>arquillian-protocol-servlet</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p(info). %By default, JBoss AS 7 deploys test archives to the server using the JMX protocol. We've gone ahead and added the dependency for the Servlet protocol in the @arquillian-jbossas-managed@ profile just so it's there if you need to use it in the future. See "this FAQ":https://community.jboss.org/wiki/WhyDoIGetNoActiveContextsForScopeTypeWhenTestingOnJBossAS7 for instructions on how to switch to it.%

p. You now have the choice of running the tests in one of three containers.

p. If you're having trouble with the pom.xml up to this point, you can download the file "pom.xml":https://raw.github.com/arquillian/arquillian-examples/master/arquillian-tutorial/pom.xml from the "example project":https://github.com/arquillian/arquillian-examples/tree/master/arquillian-tutorial.

h3. Test Across Containers

When you refresh the project in Eclipse, you'll notice that it no longer builds. That's because you need to activate one of the container profiles. Let's activate the Weld EE embedded profile to restore the previous state.

There are two ways to activate a Maven profile in Eclipse (assuming you are using the "Maven Integration for Eclipse":http://www.eclipse.org/m2e):

# Manual configuration (standard approach)
# Maven profile selector (JBoss Tools)

h4. Set active Maven profile: Manual configuration

To set the active profile manually, follow these steps:

# Right click on the project and select Properties
# Select the Maven properties tab
# Enter the profile id in the Active Maven Profiles field (e.g., @arquillian-weld-ee-embedded@)
# Click the OK button and accept the project changes

Here's the Maven properties screen showing the profile we've activated:

!/images/guides/arquillian_tutorial_maven_properties.png!

h4. Set active Maven profile: Maven profile selector

If you have JBoss Tools installed, selecting the active profile becomes much easier:

# Right click on the project and select Maven > Select Active Profiles...
(alternatively, you can use the keybinding Ctrl+Shift+P or the button in the toolbar)
# Check the box next to the profile you want to activate (e.g., @arquillian-weld-ee-embedded@)
# Click the OK button

Here's the Maven profile selector dialog showing the profile we've activated:

!/images/guides/arquillian_tutorial_maven_profile_selector.png!

Once you've activate the profile, the compile errors will disappear and you'll be able to run the test again successfully.

Another option to active a profile is to set one of the profiles to be active by default. Let's make the Weld EE Embedded profile the default by adding an @<activation>@ element to the profile definition:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-weld-ee-embedded</id>
    <activation>
        <activeByDefault>true</activeByDefault>
    </activation>
    <dependencies>
        <!-- hidden -->
    </dependencies>
</profile>
<!-- clip -->

p. Now you no longer have to select a profile in the IDE since this one will be automatically selected. However, to use a different profile (exclusively), you have to first explicitly deactivate this profile.

h4. Switching between containers

You already know the test works in Weld EE Embedded. Let's switch to GlassFish embedded by repeating the steps above, this time activating only the @arquillian-glassfish-embedded@ profile.

p(info). %If you set the Weld EE Embedded profile to be active by default, you have to explicitly disable it to use another profile. You can disable a profile in the Maven Profile selector by right clicking on the entry and selecting Deactivate from the context menu. You'll see this prefixes the profile name with an exclamation mark (e.g., @!arquillian-weld-ee-embedded@). Multiple profile selections (or deactivations) are separated by commas.%

Run the test again. You should see GlassFish start in the console...and another *(greenbar)green bar*!

You've now run the same test on two different embedded containers, a CDI container (Weld) and a Java EE container (GlassFish). Both of these executions are in process. To really be sure the component works in a pure environment, we need to use a standalone container. Let's switch to using JBoss AS.

To run the test on a standalone instance of JBoss AS, you first need to set it up. You can either:

# Download and unpack it in a location outside the project
# Use Maven to download and unpack it during a build

Follow these steps to setup JBoss AS 7 outside the project:

# "Download JBoss AS 7":as7_download (make sure the version you download matches the version of the @jboss-as-arquillian-container-managed@ dependency in your @pom.xml@)
# Extract the archive
# (optional) Set the @JBOSS_HOME@ environment variable to the path of the extracted directory

If you have JBoss AS installed (i.e., extracted) and your @JBOSS_HOME@ environment variable set to that location, you can activate the @arquillian-jbossas-managed@ profile and run the test. You should see JBoss AS start in the console...and another *(greenbar)green bar*!

p(info). %The message printed to System.out gets written to the server log instead of the console, so look over there.%

If you want Maven to handle this task for you instead (optional), add the following XML fragment under the @<id>@ element of the @arquillian-jbossas-managed@ profile:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<build>
    <plugins>
        <plugin>
            <artifactId>maven-dependency-plugin</artifactId>
            <executions>
                <execution>
                    <id>unpack</id>
                    <phase>process-test-classes</phase>
                    <goals>
                        <goal>unpack</goal>
                    </goals>
                    <configuration>
                        <artifactItems>
                            <artifactItem>
                                <groupId>org.jboss.as</groupId>
                                <artifactId>jboss-as-dist</artifactId>
                                <version>7.1.1.Final</version>
                                <type>zip</type>
                                <overWrite>false</overWrite>
                                <outputDirectory>target</outputDirectory>
                            </artifactItem>
                        </artifactItems>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build> 
<!-- clip -->

p. To target a managed JBoss AS 7 instance downloaded by Maven, you also need a small bit of Arquillian configuration. Create the following configuration file and assign the value of the @jbossHome@ property to the location where JBoss AS 7 is installed. If you're using the Maven dependency plugin, the location is @target/jboss-as-7.1.1.Final@.

div(filename). src/test/resources/arquillian.xml

bc(prettify).. <arquillian xmlns="http://jboss.org/schema/arquillian"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://jboss.org/schema/arquillian
        http://jboss.org/schema/arquillian/arquillian_1_0.xsd">
    <container qualifier="jbossas-managed" default="true">
        <configuration>
            <property name="jbossHome">target/jboss-as-7.1.1.Final</property>
        </configuration>
    </container>
</arquillian>

p. Now change the active Maven profile to @arquillian-jbossas-managed@, then run the test again. You should see JBoss AS starting in the console...and yet another *(greenbar)green bar*!

That's the _same_ test, this time running in a full Java EE container. Arquillian packages the test, deploys to the container as a Java EE archive, executes the tests remotely, captures the results and feeds them back to the Eclipse JUnit result view (or in the Maven surefire results).

If you want to dive deeper into Arquillian, move on to "Getting Started: Rinse and Repeat":/guides/getting_started_rinse_and_repeat guide. To learn how to use Forge to automate Arquillian setup and test generation, read through "Get Started Faster with Forge":/guides/get_started_faster_with_forge.
