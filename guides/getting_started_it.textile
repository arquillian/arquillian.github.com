---
layout: guide
title: Guida introduttiva
authors: [mojavelinux]
translators: [flashboss]
tags: [cdi, weld, maven, forge, eclipse]
description: Impariamo ad aggiungere Arquillian alla suite di test del nostro progetto e scrivere il nostro primo test.
guide_group: 1
guide_order: 10
---
[forge_home]http://jboss.org/forge
[forge_download]https://repository.jboss.org/nexus/service/local/artifact/maven/redirect?r=releases&g=org.jboss.forge&a=forge-distribution&v=1.0.0.Final&e=zip
[maven_home]http://maven.apache.org
[maven_download]http://maven.apache.org/download.html
[maven_search]http://search.maven.org
[jdk_download]http://www.oracle.com/technetwork/java/javase/downloads
[as7_download]http://jboss.org/jbossas/downloads
[tools_home]http://jboss.org/tools
[shrinkwrap_home]http://jboss.org/shrinkwrap
[m2e_home]http://eclipse.org/m2e

Questa guida introduce Arquillian. Alla fine della lettura, potrai:

* Aggiungere l'infrastruttura di Arquillian ad un progetto basato su Maven
* Scrivere un test di Arquillian che lavora su un bean CDI(Contexts and Dependency Injection)
* Eseguire i test di Arquillian su container multipli tramite Maven ed Eclipse

Queste capacità verranno apprese incorporando Arquillian in una suite di test di un'applicazione Java EE basata su Maven. Abbiamo ideato questa guida in modo da essere di _semplice lettura_ per farti subito iniziare!

h3. Presupposti

Il modo più semplice di usare Arquillian è incorporarlo nella suite di test di un progetto usando un tool di build basato su dipendenze. Oggi, il più usato tool di questo tipo è "Apache Maven":maven_home. Questa guida vi porterà alla vostra prima *(greenbar)green bar* usando un progetto Maven.

p(info). %Arquillian non è legato nè a Maven, nè ad alcun altro tool di building. Può lavorare anche--se non meglio--con progetti basati su Ant o Gradle. E' preferibile un tool di dependency management poichè semplifica l'inclusione delle librerie di Arquillian che sono già distribuite nel "Maven Central repository":maven_search.% 

This guide assumes you have Maven available, either in your command shell or your IDE(Integrated Development Environment). If you don't, please "download and install Maven now":maven_download. You'll also need "JDK(Java Development Kit) 1.5":jdk_download or higher installed on your machine, though JDK 1.6 is preferred.

Questa guida presuppone che abbiate Maven disponibile nella shell dei comandi oppure nell'IDE(Integrated Development Environment). Altrimenti, eseguite il "download e installazione di Maven":maven_download. Avrete bisogno della "JDK(Java Development Kit) 1.5":jdk_download o superiore installata nella vostra macchina, sebbene sia preferibile la JDK 1.6.

h3. Creare un Nuovo Progetto

Ci sono due modi che raccomandiamo di usare per creare un nuovo progetto Maven:

# "Generare un progetto da un Archetype di Maven":#generate_project_from_archetype
# "Creare e personalizzare un progetto tramite JBoss Forge":#create_project_using_forge

"JBoss Forge":forge_home è di gran lunga il più semplice, ma questa guida offre entrambe le opzioni nel caso non vi sentiate pronti a usare JBoss Forge. Selezionate una delle due opzioni per saltare alle istruzioni.

p(info). %Se avete un progetto Maven già pronto, potete usare questa sezione per confrontarlo e assicurarvi che tutte le dipendenze siano presenti prima di iniziare.%

h4(#generate_project_from_archetype). Generare un Progetto da un Archetype di Maven

Per prima cosa, creiamo un progetto Java basato su Maven con il seguente comando:

bc(command).. $ mvn archetype:generate -DarchetypeGroupId=net.avh4.mvn.archetype \
-DarchetypeArtifactId=java-1.6-archetype

p. _Copiate il testo dopo il @$@ e copiatelo nella vostra shell dei comandi_. Al prompt, inserite il valore mostrato dopo ogni virgoletta nel pannello in basso. Premete Enter dopo ogni valore (come indicato da @<ENTER>@).

bc(output). Define value for property 'groupId': : org.arquillian.example <ENTER>
Define value for property 'artifactId': : arquillian-tutorial <ENTER>
Define value for property 'version': : <ENTER>
Define value for property 'package': : <ENTER>
Confirm properties configuration:
groupId: org.arquillian.example
artifactId: arquillian-tutorial
version: 1.0-SNAPSHOT
package: org.arquillian.example
Y: : <ENTER>

p. Il comando ha creato un progetto Maven dentro la directory corrente in una nuova directory chiamata @arquillian-tutorial@. Entriamo in questa nuova directory. La struttura dei file del progetto è mostrata in basso.

(filetree)* src/
** main/
*** java/ - Quì vanno tutti i file sorgenti Java dell'applicazione (sotto il package Java)
*** resources/ - Quì vanno tutti i file di configurazione dell'applicazione
** test/
*** java/ - Quì vanno tutti i sorgenti Java delle classi di test (sotto il package Java)
*** resources/ - Quì vanno tutti i file di configurazione dei test (p.es., arquillian.xml)
* pom.xml - Il file di build di Maven. Istruisce Maven su come deve essere costruito il progetto.

Il generatore del progetto ha creato anche un package Java con nome @org.arquillian.example@ sotto le due directory @java@. Quì dovrete mettere tutti i sorgenti Java invece di usare la root come directory @java@.

Andiamo avanti e apriamo il @pom.xml@ nel nostro editor. Dovreste vedere un file XML contenente le informazioni base del progetto, una sezione build e una sezione dependencies.

p(info). %Noterete che il progetto è configurato con Java 1.6 e JUnit 4.8, rispettivamente le versioni minime di Java e JUnit raccomandate da Arquillian.%

p(warning). %Arquillian supporta anche TestNG 5 ma in questa guida ci limiteremo a usare JUnit%

*Tutti gli elementi @<dependency>@ sotto la dependency JUnit possono essere rimosse se non richieste.* Dopo questa modifica, il file dovrebbe diventare uguale al contenuto quì in basso (leggermente riformattato):

div(filename). pom.xml

bc(prettify).. <?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.arquillian.example</groupId>
    <artifactId>arquillian-tutorial</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>arquillian-tutorial</name>
    <url>http://arquillian.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>

p. Iniziamo ora a scrivere i componenti Java EE 6. Abbiamo quindi bisogno di aggiungere le API Java EE 6 al classpath in modo da poterli compilare.

Apriamo nuovamente il file @pom.xml@ e aggiungiamo il seguente frammento XML direttamente dentro l'elemento @<dependencies>@. Quì in basso vediamo come dovrebbe diventare l'elemento @<dependencies>@ una volta terminato:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>org.jboss.spec</groupId>
        <artifactId>jboss-javaee-6.0</artifactId>
        <version>1.0.0.Final</version>
        <type>pom</type>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.8.1</version>
        <scope>test</scope>
    </dependency>
</dependencies>
<!-- clip -->

p(important). %L'artifact @org.jboss.spec:jboss-javaee-6.0@ contiene soltanto le API standard di Java EE 6. Raccomandiamo *fortemente* di *non usare* l'artifact delle API Java EE con coordinate @javax:javaee-api@. L'ultimo artifact contiene classi con il corpo dei metodi ridotto all'osso, le quali causano all'applicazione di lanciare errori oscuri di codice assente se aggiunte a runtime nel classpath (perfino durante l'esecuzione dei test). "Leggete queste FAQ":https://community.jboss.org/wiki/WhatsTheCauseOfThisExceptionJavalangClassFormatErrorAbsentCode per più dettagli.%

p. La base del progetto è pronta! Saltiamo alla sezione, "Aprire il Progetto con Eclipse":#open_the_project_in_eclipse, in modo da iniziare a scrivere codice!

h4(#create_project_using_forge). Creare un Progetto Con Forge

"JBoss Forge":forge_home è una shell di comandi per creare rapidamente applicazioni in modo standard. Possiamo considerarlo un Maven Archetypes con gli steroidi.

Installing Forge is a relatively short process, and this guide will take you through the fundamentals. Follow these simple steps to get Forge installed:

L'installazione di Forge è molto rapida, e questa guida ne spiegherà i passi fondamentali. Seguite questi semplici passaggi per installare Forge:

# "Scarichiamo Forge":forge_download
# Eseguiamo l'unzip della distribuzione in una directory del nostro harddrive, che chiameremo @$FORGE_HOME@
  Presupponiamo che la distribuzione sia stata estratta in una directory con nome @forge@
# Aggiungiamo @$FORGE_HOME/bin@ nel nostro path (Windows, Linux o Mac OSX)

Su sistemi operativi basati su Unix, aggiungere Forge al path significa solitamente di editare i file $HOME/.bashrc o $HOME/.profile; avremo bisogno di aggiungere le seguenti variabili di ambiente:

bc(command). $ export FORGE_HOME=$HOME/forge/
$ export PATH=$PATH:$FORGE_HOME/bin

p(info). %Su Windows, bisogna aprire il "Pannello di Controllo", cliccare su "Proprietà di Sistema", aprire il tab "Avanzate", cliccare su "Variabili d'Ambiente" e aggiungere visualmente le due variabili. Raccomandiamo di impostare queste variabili per Forge, a meno che non venga fatto l'unzip della distribuzione in una directory accessibile a tutti gli utenti.%

Ora che Forge è installato (o meglio, estratto), accediamo ad un prompt dei comandi della shell e lanciamo il comando @forge@:

bc(command).. $ forge
   _____                    
  |  ___|__  _ __ __ _  ___ 
  | |_ / _ \| `__/ _` |/ _ \  \\
  |  _| (_) | | | (_| |  __/  //
  |_|  \___/|_|  \__, |\___| 
                  |___/      
 
[no project] ~ $

p. Questo è tutto! Abbiamo lanciato e attivato Forge. Ora è tempo di creare il progetto.

Nella shell di Forge, eseguiamo il seguente comando per creare un progetto vuoto, molto simile a come abbiamo creato precedentemente il progetto con Maven Archetype:

bc(command). $ new-project --named arquillian-tutorial --topLevelPackage org.arquillian.example

p. Questo comando genera un progetto basato su Maven in una nuova directory con nome @arquillian-tutorial@ sotto la directory corrente.

La struttura dei file del progetto generato da Forge è mostrato in basso: 

(filetree)* src/
** main/
*** java/ - Quì vanno tutti i file sorgenti Java dell'applicazione (sotto il package Java)
*** resources/ - Quì vanno tutti i file di configurazione dell'applicazione
**** META-INF/
***** forge.xml - Il file di configurazione di Forge vuoto
** test/
*** java/ - Quì vanno tutti i sorgenti Java delle classi di test (sotto il package Java)
*** resources/ - Quì vanno tutti i file di configurazione dei test (p.es., arquillian.xml)
* pom.xml - Il file di build di Maven. Istruisce Maven su come deve essere costruito il progetto.

Forge fa in modo che la directory del progetto diventi la directory corrente all'interno della shell. 

bc(command). [arquillian-tutorial] arquillian-tutorial $ 

Per default, Forge configura il progetto con Java 1.6, la versione minima di Java raccomandata da Arquillian, piuttosto comodo.

Bisogna ora aggiungere le API di Java EE. Viene fatto tramite il comando @project add-dependency@ mostrato quì in basso:

bc(command). $ project add-dependency org.jboss.spec:jboss-javaee-6.0:1.0.0.Final:provided:pom

Bisogna anche aggiungere la dipendenza di JUnit 4.8, la versione minima richiesta da Arquillian, con scope di tipo test:

bc(command). $ project add-dependency junit:junit:4.8.1:test

Forge aggiunge il repository della Community JBoss nel file pom.xml. Questo repository non è indispensabile per Arquillian. (E' preferibile comunque mantenerlo se si necessitano altre librerie della Community JBoss). Se si vuole rimuovere il repository, è sufficiente usare il seguente comando di Forge:

bc(command). $ project remove-repository http://repository.jboss.org/nexus/content/groups/public 

Il risultato del pom.xml generato da Forge è mostrato quì in basso:

div(filename). pom.xml

bc(prettify).. <?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xsi:schemaLocation="
        http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/xsd/maven-4.0.0.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.arquillian.example</groupId>
    <artifactId>arquillian-tutorial</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <build>
        <finalName>arquillian-tutorial</finalName>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.6</source>
                    <target>1.6</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

p. Il progetto base è pronto! Apriamo ora il progetto con Eclipse in modo da iniziare a scrivere del codice!

h3. Aprire il Progetto con Eclipse

Quando si sviluppa un progetto Java, è preferibile usare un IDE come Eclipse. Questo perchè Arquillian è progettato per essere IDE friendly. Si possono lanciare i test di Arquillian dall'IDE senza configurazioni particolari. Diamo subito uno sguardo ai vantaggi forniti dall'IDE.

Prima di Lanciare Eclipse, siccome il nostro è un progetto Maven, abbiamo bisogno di installare il plugin "Maven Integration for Eclipse":m2e_home (m2e), se non presente. 

h4. Installare il plugin m2e

If you don't already have the m2e plugin installed, the simplest way to get it is to install "JBoss Tools":tools_home. Follow these steps to install it from the Eclipse Marketplace (sort of like the app store for Eclipse).

# Select @Help > Eclipse Marketplace...@ from the main menu
# Type "jboss tools" (without quotes) in the Find input field, then press Enter
# Click the Install button next to JBoss Tools (Indigo)
# Complete the install wizard, then restart Eclipse if prompted

JBoss Tools provides a nice environment for developing Java EE applications, including excellent CDI support. Don't worry, it's not a heavyweight plugin.

However, if you just want the Maven integration without the extras that JBoss Tools brings, you can follow these steps instead:

# Select @Help > Eclipse Marketplace...@ from the main menu
# Type "maven" (without quotes) in the Find input field, then press Enter
# Click the Install button next to Maven Integration for Eclipse
# Complete the install wizard, then restart Eclipse if prompted
# Repeat the steps to install the Maven Integration for Eclipse WTP

h4. Using m2e to import the project

Once you have the Maven Integration plugin installed, follow these steps to open the project:

# Select @File > Import...@ from the main menu
# Type "existing maven" (without quotes) in the import source field
# Select the option Existing Maven Projects, then click the Next button
# Click the Browse... button
# Navigate to the project folder in the file browser, select it, then click the OK button
# Click the Finish button to open the project

Eclipse will recognize the Maven project and open it in the Project Navigator view. If you expand the project, it should look similar to this image:

!/images/guides/arquillian_tutorial_eclipse_project.png!

Now we can really get down to business!

h3. Create a Component

In order to write an Arquillian test, we need to have a component for it to test. Let's begin by creating a basic component so that you can learn how to execute an Arquillian test without other distractions. We'll gradually move to more complex scenarios.

In your IDE, create a new Java class named @Greeter@ in the @org.arquillian.example@ package. Replace the contents of the file with this greeter logic:

div(filename). src/main/java/org/arquillian/example/Greeter.java

bc(prettify).. package org.arquillian.example;

import java.io.PrintStream;

/**
 * A component for creating personal greetings.
 */
public class Greeter {
    public void greet(PrintStream to, String name) {
        to.println(createGreeting(name));
    }

    public String createGreeting(String name) {
        return "Hello, " + name + "!";
    }
}

p. We want to verify that this class behaves properly when invoked as a CDI(Contexts and Dependency Injection) bean. Of course, we could simply write a unit test. But let's pretend that the bean uses enterprise services such as dependency injection and messaging and must be used inside a container. (Besides, that way we give it room to grow ~;))

To use the class as a CDI bean, we'll be injecting it into the test using the @@Inject@ annotation. That calls for an Arquillian test! That means it's time to add the Arquillian API to the project!

h3. Add the Arquillian APIs

Once again open up the @pom.xml@ file at the root of the project in your editor. We need to instruct Maven which versions of the artifacts to use. Insert the following XML fragment directly above the @<build>@ element to import the BOM(Bill of Materials), or version matrix, for Arquillian's transitive dependencies.

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian</groupId>
            <artifactId>arquillian-bom</artifactId>
            <version>#{site.components['arquillian-core'].latest_version}</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
    </dependencies>
</dependencyManagement>
<!-- clip -->

p. Next, append the following XML fragment directly under the last @<dependency>@ element to add the Arquillian JUnit integration:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.junit</groupId>
    <artifactId>arquillian-junit-container</artifactId>
    <scope>test</scope>
</dependency>
<!-- clip -->

p. The Arquillian JUnit integration artifact also adds the Arquillian Core and ShrinkWrap APIs to the test classpath. You need all of these libraries to write and compile a JUnit Arquillian test.

p(info). %To use TestNG instead of JUnit, substitute the Arquillian JUnit integration with the Arquillian TestNG integration.%

(Optional) We recommend upgrading the Maven Surefire Plugin from the default version, for reasons described in "this FAQ":https://community.jboss.org/wiki/WhatVersionOfSurefireShouldIUseToRunMyArquillianTestsInAMavenBuild. You can set the version of the Surefire Plugin by appending this @<plugin>@ element inside the @<plugins>@ element, just below the Maven Compiler Plugin:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<plugin>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.12</version>
</plugin>
<!-- clip -->

p. If you're having trouble with the pom.xml up to this point, you can download the file "pom-no-container-profiles.xml":https://raw.github.com/arquillian/arquillian-examples/master/arquillian-tutorial/pom-no-container-profiles.xml from the "example project":https://github.com/arquillian/arquillian-examples/tree/master/arquillian-tutorial and rename it to pom.xml.

*You're all set to write your first Arquillian test!*

h3. Write an Arquillian Test

An Arquillian test looks just like a unit test, just with some extra flair. Let's return to the IDE to create one.

p(warning). %If you get the message "Project configuration is out of date with pom.xml" then right click and select Project > Maven > Update Project Configuration to resync the project.%

Begin by creating a new JUnit test case in src/test/java named @GreeterTest@ and assign it the package name @org.arquillian.example@. You won't need the typical JUnit setup and tearDown methods since Arquillian will handle the heavy lifting. Here's what we have so far:

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.junit.Assert;
import org.junit.Test;

public class GreeterTest {
    @Test
    public void should_create_greeting() {
        Assert.fail("Not yet implemented");
    }
}

p. Now, about that flair. An Arquillian test case must have three things:

# A @@RunWith(Arquillian.class)@ annotation on the class
# A public static method annotated with @@Deployment@ that returns a ShrinkWrap archive
# At least one method annotated with @@Test@

The @@RunWith@ annotation tells JUnit to use Arquillian as the test controller. Arquillian then looks for a public static method annotated with the @@Deployment@ annotation to retrieve the test archive (i.e., micro-deployment). Then some magic happens and each @@Test@ method is run inside the container environment.

h4. What's a test archive?

The purpose of the test archive is to isolate the classes and resources which are needed by the test from the remainder of the classpath. Unlike a normal unit test, Arquillian does not simply tap the entire classpath. Instead, you include only what the test needs (which may be the entire classpath, if that's what you decide). The archive is defined using "ShrinkWrap":shrinkwrap_home, which is a Java API for creating archives (e.g., jar, war, ear) in Java. The micro-deployment strategy let's you focus on precisely the classes you want to test. As a result, the test remains very lean and manageable.

Once the ShrinkWrap archive is deployed to the server, it becomes a real archive. The container deployer has no knowledge that the archive was package by ShrinkWrap. You can think of ShrinkWrap as a Java-based build tool, with one exception. In the optimal case, it streams the archive to the server instead of writing the archive to disk. But what it creates is an authentic archive.

p(info). %ShrinkWrap also supports resolving artifacts (libraries) and create configuration files programmatically, which can then be added to the test archive. For a more thorough introduction to ShrinkWrap, see the "ShrinkWrap introduction":/guides/shrinkwrap_introduction guide.%

Let's add that Arquillian flair to the test by replacing its contents with the code below:

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class GreeterTest {

    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(Greeter.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Test
    public void should_create_greeting() {
        Assert.fail("Not yet implemented");
    }
}

p. Using ShrinkWrap, we've defined a Java archive (jar) as the deployment. It includes the @Greeter@ class that the test will invoke and an empty beans.xml in the META-INF directory to activate CDI in this archive.

If you want to see the contents of the archive that ShrinkWrap creates when the test is run, you can print the archive to stdout (i.e., the console) before returning it.

bc(prettify).. @Deployment
public static JavaArchive createDeployment() {
    JavaArchive jar = ShrinkWrap.create(JavaArchive.class)
        .addClass(Greeter.class)
        .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    System.out.println(jar.toString(true));
    return jar;
}

p. This produces the following output when the test is run: 

bc(output). 2ac9cd28-a71a-479a-a785-750b40221766.jar:
/META-INF/
/META-INF/beans.xml
/org/
/org/arquillian/
/org/arquillian/example/
/org/arquillian/example/Greeter.class

ShrinkWrap assigned the archive a random name since we didn't specify one explicitly. We'll cover another way to inspect the archive in the follow-up guide, "Getting Started: Rinse and Repeat":/guides/getting_started_rinse_and_repeat/#export_the_deployment.

Now all we need to do is inject the @Greeter@ instance into a field directly above the test method and replace the unimplemented test method with one that asserts the behavior of the bean. To give you that warm fuzzy feeling, we'll also print the greeting to the console. Replace the test method with the code below and add an import for @javax.inject.Inject@.

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. // clip
import javax.inject.Inject;
// clip

@Inject
Greeter greeter;

@Test
public void should_create_greeting() {
    Assert.assertEquals("Hello, Earthling!",
        greeter.createGreeting("Earthling"));
    greeter.greet(System.out, "Earthling");
}

p. Here's how the test should look when you're done:

div(filename). src/test/java/org/arquillian/example/GreeterTest.java

bc(prettify).. package org.arquillian.example;

import javax.inject.Inject;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.Test;
import org.junit.Assert;
import org.junit.runner.RunWith;

@RunWith(Arquillian.class)
public class GreeterTest {

    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
            .addClass(Greeter.class)
            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Inject
    Greeter greeter;

    @Test
    public void should_create_greeting() {
        Assert.assertEquals("Hello, Earthling!",
            greeter.createGreeting("Earthling"));
        greeter.greet(System.out, "Earthling");
    }
}

p. You've written your first Arquillian test!

Ah, but you're probably wondering how to run it ~:S If you're thinking, "Just like a unit test", then you're correct! However, we first need to add a container adapter to the classpath.

h3. Add a Container Adapter

We've been talking a lot about testing in a container, but so far we haven't discussed which one we'll be using. That's because it's a runtime decision.

Arquillian selects the target container based on which container adapter is available on the test classpath. A _container adapter_ is that controls and communicates with the container (it's not a container itself). That means we'll be adding more libraries to the project.

An Arquillian test can be executed in any container that is compatible with the programming model used in the test (as long as that container has an Arquillian adapter, of course). Our test is using the CDI programming model, so we need to use any container to supports CDI. We want fast turnaround during development, so we'll start with the Weld EE embedded container.

Open the @pom.xml@ file again and add the following group of dependencies directly below the other @<dependency>@ elements:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependency>
    <groupId>org.jboss.arquillian.container</groupId>
    <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
    <version>1.0.0.CR3</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.jboss.weld</groupId>
    <artifactId>weld-core</artifactId>
    <version>1.1.5.Final</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-simple</artifactId>
    <version>1.6.4</version>
    <scope>test</scope>
</dependency>
<!-- clip -->

p. To summarize, here are the three libraries you need to use Arquillian (with JUnit):

# Arquillian JUnit integration
# Arquillian container adapter for the target container
# Container runtime (for an embedded container) or container client (for a remote container)

We're using an embedded container in this example, so we need the container runtime, Weld.

Now back to the test.

h3. Run the Arquillian Test

Once you add all the necessary Arquillian libraries to the classpath, you can run an Arquillian test just like a unit test, whether you are running it from the IDE, the build script or any other test plugin. Let's run the test in Eclipse.

From the IDE window, right click on the GreeterTest.java file in the Package Explorer (or in the editor) and select Run As > JUnit Test from the context menu.

!/images/guides/arquillian_tutorial_run_junit_test.png!

When you run the test, you should see the following lines printed to the console:

bc(output). 21 [main] INFO org.jboss.weld.Version - WELD-000900 1.1.5 (Final)
Hello, Earthling!

You should then see the JUnit view appear, revealing a *(greenbar)green bar*!

!/images/guides/arquillian_tutorial_junit_green_bar.png!

You can also run the test on the commandline using Maven:

bc(command). $ mvn test

You should see the following lines printed to the console:

bc(output). -------------------------------------------------------
T E S T S
-------------------------------------------------------
Running org.arquillian.example.GreeterTest
19 [main] INFO org.jboss.weld.Version - WELD-000900 1.1.5 (Final)
Hello, Earthling!
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.907 sec

*Congratulations!* You've earned your first *(greenbar)green bar* with Arquillian!

h3. A Closer Look

How do you know that CDI really worked? For all you know, Arquillian created a new instance of the @Greeter@ class and injected it into the test without any involvement from CDI. Let's prove it's there.

Create a new CDI bean named @PhraseBuilder@ in the @org.arquillian.example@ package that can create phrases from templates.

div(filename). src/main/java/org/arquillian/example/PhraseBuilder.java

bc(prettify).. package org.arquillian.example;

import java.text.MessageFormat;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.PostConstruct;

public class PhraseBuilder {
    private Map<String, String> templates;

    public String buildPhrase(String id, Object... args) {
        return MessageFormat.format(templates.get(id), args);
    }

    @PostConstruct
    public void initialize() {
        templates = new HashMap<String, String>();
        templates.put("hello", "Hello, {0}!");
    }
}

p. Next, open up the @Greeter@ class and create a new constructor that will inject @PhraseBuilder@ using constructor injection. Then, delegate the task of creating the greeting to the injected bean.

div(filename). src/main/java/org/arquillian/example/Greeter.java

bc(prettify).. package org.arquillian.example;

import java.io.PrintStream;
import javax.inject.Inject;

public class Greeter {

    private PhraseBuilder phraseBuilder;

    @Inject
    public Greeter(PhraseBuilder phraseBuilder) {
        this.phraseBuilder = phraseBuilder;
    }

    public void greet(PrintStream to, String name) {
        to.println(createGreeting(name));
    }

    public String createGreeting(String name) {
        return phraseBuilder.buildPhrase("hello", name);
    }
}

p. Now, in order for the test to work, an instance of @PhraseBuilder@ must be created, its @@PostConstruct@ method must be invoked and it must be injected into the constructor of @Greeter@ when an instance of @Greeter@ is created. We can be certain CDI is working if all that comes together.

p. One last step. Because we created a new class, we must be sure that it gets add to the test archive returned by the test's @@Deployment@ method. Simply change this line:

bc(prettify).. .addClass(Greeter.class)

p. ...to this one:

bc(prettify).. .addClasses(Greeter.class, PhraseBuilder.class)

p. Run the test again. You should get another *(greenbar)green bar*! Feels good, doesn't it?

h3. Debug the Test

This is going to be a short chapter. Why? Because an Arquillian test is so straightforward that you debug it exactly how you debug a unit test. Just add a breakpoint anywhere--either in the test or in the application code. Then right click on the file and select Debug As > JUnit Test. You're now debugging in the container! Have fun poking around!

!/images/guides/arquillian_tutorial_debugging_test.png!

p(warning). %If you're using a remote container, Debug As does not cause breakpoints to be activated. Instead, you need to start the container in debug mode and attach the debugger. That's because the test is run in a different JVM than the original test runner.%

As you've just witnessed, Arquillian is the ideal tool for testing CDI applications. It takes care of loading the CDI environment and injecting beans directly into the test. Best of all, when using an embedded CDI container, the test runs just as quickly as a unit test. If that's all you need, then you can exit the tutorial now and start writing tests.

*But wait!* Is the embedded container telling the whole story? Will the component work if running inside a full container?

One of the perks of Arquillian is that you can run the same test in different compatible containers, whether it's another embedded container or a standalone container. If you intend to use a real container, read on.

h3. Add More Containers

As you learned earlier, Arquillian selects the container based on which container adapter is on the classpath. To switch to another container, you just change which container adapter is on the classpath before you run the test.

p(important). %You can only have one container adapter on the classpath at a time. Arquillian will abort execution of the test if it detects multiple adapters.%

One way to swap the libraries on the classpath is to manually edit the dependencies defined in @pom.xml@. But that's just tedious. The recommended approach is to use Maven profiles.

h4. Setting up Maven profiles

Maven profiles allow you to partition your dependencies into groups, one group for each container adapter and its related artifacts. When running the tests, you activate one of those groups, which in turn selects a target container. The profile is activated either using either a commandline flag (-P) or a preference in the IDE.

Open up the @pom.xml@ and create a new profile for Weld EE embedded by inserting the following XML directly under the @<dependencies>@ element:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profiles>
    <profile>
        <id>arquillian-weld-ee-embedded</id>
        <dependencies>
            <dependency>
                <groupId>org.jboss.spec</groupId>
                <artifactId>jboss-javaee-6.0</artifactId>
                <version>1.0.0.Final</version>
                <type>pom</type>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.arquillian.container</groupId>
                <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
                <version>1.0.0.CR3</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.weld</groupId>
                <artifactId>weld-core</artifactId>
                <version>1.1.5.Final</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-simple</artifactId>
                <version>1.6.4</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </profile>
</profiles>
<!-- clip -->

p. Next, *remove* the @jboss-javaee-6.0@ dependency and the dependencies for the Weld EE embedded container adapter from the main @<dependencies>@ section. Here's how the @<dependencies>@ and @<profiles>@ sections should look when you're done:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.8.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.jboss.arquillian.junit</groupId>
        <artifactId>arquillian-junit-container</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
<profiles>
    <profile>
        <id>arquillian-weld-ee-embedded</id>
        <dependencies>
            <dependency>
                <groupId>org.jboss.spec</groupId>
                <artifactId>jboss-javaee-6.0</artifactId>
                <version>1.0.0.Final</version>
                <type>pom</type>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.arquillian.container</groupId>
                <artifactId>arquillian-weld-ee-embedded-1.1</artifactId>
                <version>1.0.0.CR3</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.jboss.weld</groupId>
                <artifactId>weld-core</artifactId>
                <version>1.1.5.Final</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-simple</artifactId>
                <version>1.6.4</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </profile>
</profiles>
<!-- clip -->

p(info). %The Java EE API dependency has been moved to the profile since some containers, like Embedded GlassFish, already provide these libraries. Having both on the classpath at the same time results in conflicts. Therefore, we have to play this classpath dance.%

We'll now include two additional profiles in the @pom.xml@ inside the @<profiles>@ element, the first for "Embedded GlassFish":http://embedded-glassfish.java.net:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-glassfish-embedded</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.arquillian.container</groupId>
            <artifactId>arquillian-glassfish-embedded-3.1</artifactId>
            <version>1.0.0.CR3</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.glassfish.main.extras</groupId>
            <artifactId>glassfish-embedded-all</artifactId>
            <version>3.1.2</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p. and the other for JBoss AS managed:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-jbossas-managed</id>
    <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-6.0</artifactId>
            <version>1.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.as</groupId>
            <artifactId>jboss-as-arquillian-container-managed</artifactId>
            <version>7.1.1.Final</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.jboss.arquillian.protocol</groupId>
            <artifactId>arquillian-protocol-servlet</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</profile>
<!-- clip -->

p(info). %By default, JBoss AS 7 deploys test archives to the server using the JMX protocol. We've gone ahead and added the dependency for the Servlet protocol in the @arquillian-jbossas-managed@ profile just so it's there if you need to use it in the future. See "this FAQ":https://community.jboss.org/wiki/WhyDoIGetNoActiveContextsForScopeTypeWhenTestingOnJBossAS7 for instructions on how to switch to it.%

p. You now have the choice of running the tests in one of three containers.

p. If you're having trouble with the pom.xml up to this point, you can download the file "pom.xml":https://raw.github.com/arquillian/arquillian-examples/master/arquillian-tutorial/pom.xml from the "example project":https://github.com/arquillian/arquillian-examples/tree/master/arquillian-tutorial.

h3. Test Across Containers

When you refresh the project in Eclipse, you'll notice that it no longer builds. That's because you need to activate one of the container profiles. Let's activate the Weld EE embedded profile to restore the previous state.

There are two ways to activate a Maven profile in Eclipse (assuming you are using the "Maven Integration for Eclipse":http://www.eclipse.org/m2e):

# Manual configuration (standard approach)
# Maven profile selector (JBoss Tools)

h4. Set active Maven profile: Manual configuration

To set the active profile manually, follow these steps:

# Right click on the project and select Properties
# Select the Maven properties tab
# Enter the profile id in the Active Maven Profiles field (e.g., @arquillian-weld-ee-embedded@)
# Click the OK button and accept the project changes

Here's the Maven properties screen showing the profile we've activated:

!/images/guides/arquillian_tutorial_maven_properties.png!

h4. Set active Maven profile: Maven profile selector

If you have JBoss Tools installed, selecting the active profile becomes much easier:

# Right click on the project and select Maven > Select Active Profiles...
(alternatively, you can use the keybinding Ctrl+Shift+P or the button in the toolbar)
# Check the box next to the profile you want to activate (e.g., @arquillian-weld-ee-embedded@)
# Click the OK button

Here's the Maven profile selector dialog showing the profile we've activated:

!/images/guides/arquillian_tutorial_maven_profile_selector.png!

Once you've activate the profile, the compile errors will disappear and you'll be able to run the test again successfully.

Another option to active a profile is to set one of the profiles to be active by default. Let's make the Weld EE Embedded profile the default by adding an @<activation>@ element to the profile definition:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<profile>
    <id>arquillian-weld-ee-embedded</id>
    <activation>
        <activeByDefault>true</activeByDefault>
    </activation>
    <dependencies>
        <!-- hidden -->
    </dependencies>
</profile>
<!-- clip -->

p. Now you no longer have to select a profile in the IDE since this one will be automatically selected. However, to use a different profile (exclusively), you have to first explicitly deactivate this profile.

h4. Switching between containers

You already know the test works in Weld EE Embedded. Let's switch to GlassFish embedded by repeating the steps above, this time activating only the @arquillian-glassfish-embedded@ profile.

p(info). %If you set the Weld EE Embedded profile to be active by default, you have to explicitly disable it to use another profile. You can disable a profile in the Maven Profile selector by right clicking on the entry and selecting Deactivate from the context menu. You'll see this prefixes the profile name with an exclamation mark (e.g., @!arquillian-weld-ee-embedded@). Multiple profile selections (or deactivations) are separated by commas.%

Run the test again. You should see GlassFish start in the console...and another *(greenbar)green bar*!

You've now run the same test on two different embedded containers, a CDI container (Weld) and a Java EE container (GlassFish). Both of these executions are in process. To really be sure the component works in a pure environment, we need to use a standalone container. Let's switch to using JBoss AS.

To run the test on a standalone instance of JBoss AS, you first need to set it up. You can either:

# Download and unpack it in a location outside the project
# Use Maven to download and unpack it during a build

Follow these steps to setup JBoss AS 7 outside the project:

# "Download JBoss AS 7":as7_download (make sure the version you download matches the version of the @jboss-as-arquillian-container-managed@ dependency in your @pom.xml@)
# Extract the archive
# (optional) Set the @JBOSS_HOME@ environment variable to the path of the extracted directory

If you have JBoss AS installed (i.e., extracted) and your @JBOSS_HOME@ environment variable set to that location, you can activate the @arquillian-jbossas-managed@ profile and run the test. You should see JBoss AS start in the console...and another *(greenbar)green bar*!

p(info). %The message printed to System.out gets written to the server log instead of the console, so look over there.%

If you want Maven to handle this task for you instead (optional), add the following XML fragment under the @<id>@ element of the @arquillian-jbossas-managed@ profile:

div(filename). pom.xml

bc(prettify).. <!-- clip -->
<build>
    <plugins>
        <plugin>
            <artifactId>maven-dependency-plugin</artifactId>
            <executions>
                <execution>
                    <id>unpack</id>
                    <phase>process-test-classes</phase>
                    <goals>
                        <goal>unpack</goal>
                    </goals>
                    <configuration>
                        <artifactItems>
                            <artifactItem>
                                <groupId>org.jboss.as</groupId>
                                <artifactId>jboss-as-dist</artifactId>
                                <version>7.1.1.Final</version>
                                <type>zip</type>
                                <overWrite>false</overWrite>
                                <outputDirectory>target</outputDirectory>
                            </artifactItem>
                        </artifactItems>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build> 
<!-- clip -->

p. To target a managed JBoss AS 7 instance downloaded by Maven, you also need a small bit of Arquillian configuration. Create the following configuration file and assign the value of the @jbossHome@ property to the location where JBoss AS 7 is installed. If you're using the Maven dependency plugin, the location is @target/jboss-as-7.1.1.Final@.

div(filename). src/test/resources/arquillian.xml

bc(prettify).. <arquillian xmlns="http://jboss.org/schema/arquillian"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://jboss.org/schema/arquillian
        http://jboss.org/schema/arquillian/arquillian_1_0.xsd">
    <container qualifier="jbossas-managed" default="true">
        <configuration>
            <property name="jbossHome">target/jboss-as-7.1.1.Final</property>
        </configuration>
    </container>
</arquillian>

p. Now change the active Maven profile to @arquillian-jbossas-managed@, then run the test again. You should see JBoss AS starting in the console...and yet another *(greenbar)green bar*!

That's the _same_ test, this time running in a full Java EE container. Arquillian packages the test, deploys to the container as a Java EE archive, executes the tests remotely, captures the results and feeds them back to the Eclipse JUnit result view (or in the Maven surefire results).

If you want to dive deeper into Arquillian, move on to "Getting Started: Rinse and Repeat":/guides/getting_started_rinse_and_repeat guide. To learn how to use Forge to automate Arquillian setup and test generation, read through "Get Started Faster with Forge":/guides/get_started_faster_with_forge.
